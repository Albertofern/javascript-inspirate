# Capítulo 6 - Números e datas

{:: encoding="utf-8" /}
{footnotes-off}
{:: encoding="utf-8" /}
{footnotes-off}

JavaScript ao igual que outras moitas linguaxes, permite o traballo matemático, aínda non sendo unha linguaxe especialmente deseñado pra científicos e matemáticos.

Ao longo deste capítulo veremos que en JavaScript existen dúas formas básicas de traballar cos *"números"*, por un lado facendo uso de *[Number](https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Math)*, e polo outro con *[Math](https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Math)*, en función da complexidade dos nosos algoritmos.

Polo xeral, é interesante utilizar certas librerías chave que facilitarannos moito o desenvolvemento cando traballamos con temas numéricos, presentaréivolas ao longo deste capítulo.

## *[Numbers](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)*

A hora de traballar con números, pode darse o caso de encontrarnos coa *[notación científica](https://es.wikipedia.org/wiki/Notaci%C3%B3n_cient%C3%ADfica)* en vez do formato ao que estamos acostumados. O seu valor e tipo de variable mantéñense anque represéntese de forma diferente.

Se desexamos traballar con unidades monetarias, podemos facer uso da librería *[accounting.js](http://openexchangerates.github.io/accounting.js/)*.

### Propiedades

- ***[.MAX_VALUE](https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Number/MAX_VALUE)***

    Esta propiedade retornáranos o número (positivo) máis grande representable en JavaScript:

    {lang=js}
    ~~~~~~~
    var numero1 = 1.7976931348623157e+308;
    var numero2 = 1.7976931348623157e+310;

    function verificarValorMaximo(num){

       	if (num <= Number.MAX_VALUE) {
       	  console.log("O número non é infinito");
       	} else {
       	  console.log("O número é infinito");
        }

    }

    verificarValorMaximo(numero1);
    verificarValorMaximo(numero2);
    ~~~~~~~

- ***[.MIN_VALUE](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Number/MIN_VALUE)***

    Retornáranos o número (negativo) máis pequeno representable (5e-324)

    {lang=js}
    ~~~~~~~
    var numero1 = 5e-323;
    var numero2 = 5e-326;

    function verificarValorMinimo(num){
        if (num >= Number.MIN_VALUE) {
            console.log("O número non é infinito");
        } else {
            console.log("O número é infinito");
        }
    }

    verificarValorMinimo(numero1);
    verificarValorMinimo(numero2);
    ~~~~~~~

- ***[.POSITIVE_INFINITY](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/POSITIVE_INFINITY)***

    Retornará o valor da propiedade do obxecto *[global Infinity](https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Infinity)*, é dicir *[Infinity](https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Infinity)*.

    {lang=js}
    ~~~~~~~
    var numeroMaximo = Number.MAX_VALUE * 2
    console.log(numeroMaximo);

    if (numeroMaximo === Number.POSITIVE_INFINITY) {
     numeroMaximo = 0;
    }
    console.log(numeroMaximo);
    ~~~~~~~

- ***[.NEGATIVE_INFINITY](https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Number/NEGATIVE_INFINITY)***

    Retornará o valor negativo da propiedade do obxecto *[global Infinity](https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Infinity)*, é dicir *[-Infinity](https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Infinity)*.

    {lang=js}
    ~~~~~~~
        var numeroMinimo = (-Number.MAX_VALUE) * 2
        console.log(numeroMinimo);

        if (numeroMinimo === Number.NEGATIVE_INFINITY) {
         numeroMinimo = 0;
        }
        console.log(numeroMinimo);
    ~~~~~~~

- ***[.NaN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/NaN)***

    En ocasións ao realizar operacións matemáticas de forma errónea podemos encontrarnos con que o valor da nosa variable foi substituído por *[NAN (Not A Number)](https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Nan)*. Este é un proceso irreversible que nos obrigará a resignar o valor da variable posteriormente.
    Ata a chegada de ECMA6 a xestión e detección de estes valores era complexa, pero co novo método *[isNaN()](https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/isNaN)* podemos solventalo.

    {lang=js}
    ~~~~~~~
        NaN === NaN;        // false
        Number.NaN === NaN; // false
        isNaN(NaN);         // true
        isNaN(Number.NaN);  // true
    ~~~~~~~


### Métodos

Facemos unha recompilación simplificada dos métodos máis utilizados, anque existen moitos máis.

- ***[.toExponential()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toExponential)***

    Retorna unha cadea de texto co valor dos números en formato de potencia.

    {lang=js}
    ~~~~~~~
    var numObj = 77.1234;

    console.log(numObj.toExponential());  // 7.71234e+1
    console.log(numObj.toExponential(4)); // 7.7123e+1
    console.log(numObj.toExponential(2)); // 7.71e+1
    console.log(77.1234.toExponential()); // 7.71234e+1
    ~~~~~~~

- ***[.toFixed()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed)***

    Retorna unha cadea de texto cos números decimais.

    Anque non é a mellor forma, tamén podemos redondear o valor.

    {lang=js}
    ~~~~~~~
    var numObj = 12345.6789;
    numObj.toFixed();       //'12346' redondeo
    ~~~~~~~

    Podemos alterar a lonxitude (número de decimais) co argumento que pasamos ao método.

    {lang=js}
    ~~~~~~~
    var numObj = 12345.6789;
    numObj.toFixed();       //'12346' redondeo
    numObj.toFixed(1);      //'12345.7'
    numObj.toFixed(6);      //'12345.678900' Añadense ceros en caso necesario
    (1.23e+20).toFixed(2);  //'123000000000000000000.00'
    (0).toFixed(2);         //'0.00'
    2.34.toFixed(1);        //'2.3' redondeo
    ~~~~~~~

    Ao utilizar valores decimais negativos é importante albergalos dentro dos parénteses pra que respecte o tipo de dato tamén.

    {lang=js}
    ~~~~~~~
    -2.34.toFixed(1);       //-2.3 Números negativos non son devoltos como cadeas.
    (-2.34).toFixed(1);     //'-2.3' Con parénteses saltase a limitación
    ~~~~~~~

- ***[.toLocaleString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString)***

    Retorna una cadea co valor representado nunha linguaxe local.

    {lang=js}
    ~~~~~~~
    var numero = 3500;
    // En Local
    console.log(numero.toLocaleString());
    // En Árabe
    console.log(numero.toLocaleString('ar-EG'));
    // En Chino decimal
    console.log(numero.toLocaleString('zh-Hans-CN-u-nu-hanidec'));
    ~~~~~~~


- ***[.toPrecision()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toPrecision)***

    Devolve un numero cos decimais desexados pero sen redondear.

    {lang=js}
    ~~~~~~~
    var numero = 5.123456;
    console.log(numero.toPrecision());    // 5.123456
    console.log(numero.toPrecision(5));   // 5.1235
    console.log(numero.toPrecision(2));   // 5.1
    console.log(numero.toPrecision(1));   // 5
    console.log((1234.5).toPrecision(2)); // 1.2e+3 (En ocasións )
    ~~~~~~~

- ***[.toString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toString)***

    Devolve una cadea co número na base (hexadecimal, binaria...) que determinemos.

    {lang=js}
    ~~~~~~~
    console.log((17).toString());     // '17'
    console.log((17.2).toString());   // '17.2'
    console.log((-0xff).toString(2)); // '-11111111'
    console.log((254).toString(16));  // 'fe'
    ~~~~~~~


- ***[.parseFloat()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/parseFloat)***

    Devolve un número decimal ou enteiro partindo dunha cadea.

    {lang=js}
    ~~~~~~~
    Number.parseFloat("3.14");          // 3.14
    Number.parseFloat("314e-2");        // 3.14
    Number.parseFloat("0.0314E+2");     // 3.14
    Number.parseFloat("3.14textos..."); // 3.14
    Number.parseFloat("1textos...");    // 1
    ~~~~~~~

- ***[.parseInt()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/parseInt)***

    Devolve un número enteiro partindo dunha cadea.

    Ademais, permítenos seleccionar a base numérica sobre a que traballaremos (binaria con 2, hexadecimal con 16, etc...). Por defecto utilizase a base 10 (decimal).

    {lang=js}
    ~~~~~~~
    parseInt(" 0xF", 16);    // 15
    parseInt(" F", 16);      // 15
    parseInt("17", 8);       // 15
    parseInt(021, 8);        // 15
    parseInt("015", 10);     // 15
    parseInt(15.99, 10);     // 15
    parseInt("15,123", 10);  // 15
    parseInt("FXX123", 16);  // 15
    parseInt("1111", 2);     // 15
    parseInt("15*3", 10);    // 15
    parseInt("15e2", 10);    // 15
    parseInt("15px", 10);    // 15
    parseInt("12", 13);      // 15
    ~~~~~~~

## *[Math](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math)*


[Math](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math)
 nos aporta infinidad de recursos matemáticos avanzados como la *[constante de Euler](https://es.wikipedia.org/wiki/Constante_de_Euler-Mascheroni)*, gestión de *[logaritmos](https://es.wikipedia.org/wiki/Logaritmo)*, *[senos](https://es.wikipedia.org/wiki/Seno_(trigonometr%C3%ADa))*, *[cosenos](https://es.wikipedia.org/wiki/Coseno)*, *[tangentes](https://es.wikipedia.org/wiki/Tangente_(trigonometr%C3%ADa))*... Cada lector debe de pescudar e valorar o que realmente quere usar, xa que moitos destes métodos e propiedades van máis alá dos nosos obxectivos, e non aportan directamente valor ao contexto de aprender a programar en JavaScript.

En xeral, cando necesitemos desenvolver unha aplicación cun gran soporte matemático recorreremos a librerías como *[Mathjs](http://mathjs.org/)*.

### Métodos

Facemos unha recopilación simplificada dos métodos máis utilizados, anque existen moitos máis.

- ***[.round()](https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/objetos_globales/Math/round)***

    Devolve o valor dun número redondeado ao enteiro máis achegado.

    {lang=js}
    ~~~~~~~
    Math.round(20.5);   // 21
    Math.round(20.49);  // 20
    Math.round(-20.51); // -21
    ~~~~~~~

- ***[.Floor()](https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/objetos_globales/Math/floor)***

    Devolve o máximo enteiro menor ou igual a un número.

    {lang=js}
    ~~~~~~~
    Math.floor(20.5);   // 21
    Math.floor(20.49);  // 20
    Math.floor(-20.51); // -21
    ~~~~~~~

{pagebreak}

- ***[.random()](https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Math/random)***

    Devolve un número pseudo-aleatorio entre 0 e 1.

    - Número aleatorio entre 0 (incluído) e 1 (excluído).

        {lang=js}
        ~~~~~~~
        Math.random();
        ~~~~~~~

    - Número aleatorio entre min (incluído) e max (excluído).

        {lang=js}
        ~~~~~~~
        Math.random() * (max - min) + min;
        Math.random() * (11 - 0) + 0;
        ~~~~~~~

    - Número enteiro aleatorio entre min (incluído) e max (excluído).

        {lang=js}
        ~~~~~~~
        Math.floor(Math.random() * (11 - 0)) + 0;
        ~~~~~~~


## Dates

Sen dubida, un dos elementos que máis utilizaremos a lo longo do noso camiño polo mundo de JavaScript será o manexo de datas.

Desgraciadamente, en JavaScript o manexo de datas é bastante complexo e pouco intuitivo, o que fixo pé, a que existan moitas librerías, que facilítannos moito o día a día. Entre elas:


[Dates.js](http://www.datejs.com/)

: Permítenos unha manipulación rápida e precisa cunha séntese moi intuitiva.


[Momments.js](http://momentjs.com)

: Que apórtanos melloras na séntese, ademais dun complemento xenial pra xestionar zonas horarias.


[Timeago](http://timeago.org/)
: Permítenos converter datas a "fai xxx minutos, segundos, días..." de forma dinámica.


### Traballando con datas

O punto de partida é traballar *[instanciando](https://es.wikipedia.org/wiki/Instancia_(inform%C3%A1tica))* a *[Date()](https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Date)*, pra poder ter a nosa data... Pra aqueles que esteades familiarizados coa programación orientada a obxectos, aquí estamos usando *[new](https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Operadores/new)* pra instanciar unha nova data.

I> Pra aqueles que non esteades familiarizados aínda, non pasa nada, porque falaremos de elo máis
I> adiante... simplemente recordade, que utilizase *new* cando creamos unha nova data.

Existen moitas formas de crear novas datas, en función de que parámetro pasamos a *Date(mi_parametro)*.

{pagebreak}

- **Data Actual**

    {lang=js}
    ~~~~~~~
    var agora = new Date();
    console.log(agora);
    ~~~~~~~

- **Usando milisegundos (dende el 1/1/1970 00:00)**

    Moi recomendable.

    {lang=js}
    ~~~~~~~
    var diaDespois = new Date(3600*24*1000);
    console.log(diaDespois);
    ~~~~~~~

- **Usando cadeas de texto**

    Pouco recomendable.

    {lang=js}
    ~~~~~~~
    var newYear = new Date("January 1, 2016 00:00:00");
    ~~~~~~~

- **Usando números**

    Recomendable, aínda que ten certa complexidade oculta a simple vista.

    {lang=js}
    ~~~~~~~
    var newYear = new Date(2016, 1, 1);          // AAAA, MM, DD
    var newYear = new Date(2016, 1, 1, 0, 0, 0); // AAAA, MM, DD, HH, MM, SS
    ~~~~~~~

- ***Usando [UTC](https://es.wikipedia.org/wiki/Tiempo_universal_coordinado)***

    {lang=js}
    ~~~~~~~
    var newYear = new Date(Date.UTC(2016, 1, 1));
    ~~~~~~~

### Métodos

Facemos unha recopilación simplificada dos métodos máis utilizados, anque existen moitos máis.

No caso das datas, podemos dividir case tódolos métodos en tres categorías principais:


Getters

: Que devólvennos información concreta.


Setters

: Que permítennos axustar información concreta.


Outros

: Que facilitárannos enormemente o traballo.


W> ##### Importante
W>
W> Tódolos aqueles métodos que son susceptibles de sufrir variacións pola zona horaria, contan
W> cun "método clon" que realiza a mesma función, pero seguindo as especificacións 
W> da *[UTC](https://es.wikipedia.org/wiki/Tiempo_universal_coordinado)*,
W> como veremos a continuación.
W>
W> Por outra parte, os meses e os días da semana, comezan a contarse dende o 0, e os días da
W> semana comezan en domingo sendo este o día 0. O resto de compoñentes non sofren
W> modificacións (ano, día do mes, etc..).

#### Getters

- **Versión UTC:**

    {lang=js}
    ~~~~~~~
    var agora = new Date();
    console.log("Con UTC: ";
    console.log("==== FECHA ====");
    console.log("O ano: " + agora.getUTCFullYear());         // 4 díxitos
    console.log("O mes: " + agora.getUTCMonth());            // 0 - 11
    console.log("O día da semana: " + agora.getUTCDay()); // 0 - 6 (D - S)
    console.log("O día do mes: " + agora.getUTCDate());     // 1-31
    console.log("==== HORA ====");
    console.log("Horas: " + agora.getUTCHours());
    console.log("Minutos: " + agora.getUTCMinutes());
    console.log("Segundos: " + agora.getUTCSeconds());
    console.log("milisegundos: " + agora.getUTCMilliseconds());
    ~~~~~~~

- **Versión Local:**

    {lang=js}
    ~~~~~~~
    var agora = new Date();
    console.log("A Data é " + agora);
    console.log("==== FECHA ====");
    console.log("O ano: " + agora.getFullYear());          // 4 díxitos
    console.log("O mes: " + agora.getMonth());             // 0 - 11
    console.log("O día da semana: " + agora.getDay());  // 0 - 6 (D - S)
    console.log("O día do mes: " + agora.getDate());      // 1-31
    console.log("==== HORA ====");
    console.log("Horas: " + agora.getHours());
    console.log("Minutos: " + agora.getMinutes());
    console.log("Segundos: " + agora.getSeconds());
    console.log("Milisegundos dende 1/1/1970: "+ agora.getTime());
    console.log("milisegundos: " + agora.getMilliseconds());
    console.log("==== OTROS ====");
    console.log("Diferenza horaria respecto a UTC: " + agora.getTimezoneOffset());
    ~~~~~~~


#### Setters:

Os setters no caso das datas están plantexados como unha maneira de axustar a data e a hora dentro dun marco determinado. Vexamos o seguinte exemplo:

-  **Dentro do marco**

    {lang=js}
    ~~~~~~~
    var newYear = new Date(Date.UTC(2016, 1, 1));
    console.info("A data é " + newYear);

    newYear.setFullYear(1980);          // Pasamos a 1980
    console.info("A data é " + newYear);

    newYear.setUTCMilliseconds(1500);   // 1500ms en formato UTC
    console.info("A data é " + newYear);
    ~~~~~~~

- **Fora do marco**

    Debes ter en conta as leis naturais: un día ten 24 horas, un mes ten un máximo de 31 días...

    Si obviamos esta lóxica, JavaScript improvisa unha nova data, pero esta non soe ser correcta.


    {lang=js}
    ~~~~~~~
    newYear.setDate(56);      // Ao día 56 de Xaneiro
    console.info("A data é " + newYear);

    newYear.setUTCHours(36);  // Pasamos a hora 36 do día
    console.info("A data é " + newYear);

    newYear.setMonth(-6);     // Retrocedemos 6 meses
    console.info("A data é " + newYear);
    ~~~~~~~

#### Outros:

- ***[.toString()](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Date/toString), [.toDateString()](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Date/toDateString), [.toTimeString()](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Date/toTimeString)***

    Devolve unha cadea de texto coa data.

    {lang=js}
    ~~~~~~~
    var agora = new Date();
    agora.toString();     // Data e Hora
    agora.toDateString(); // Só Data
    agora.toTimeString(); // Só Hora
    ~~~~~~~

- ***[.toUTCString()](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Date/toUTCString), [.toISOString()](https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Date/toISOString)***.

    Devolve unha cadea coa data en formatos específicos *[UTC](https://es.wikipedia.org/wiki/Tiempo_universal_coordinado)* e *[ISO 8601](https://es.wikipedia.org/wiki/ISO_8601)*.

    O formato *[ISO 8601](https://es.wikipedia.org/wiki/ISO_8601)* será de gran axuda pra comunicarnos con outras plataformas, librerías e sistemas, polo tanto... **¡aprende como funciona!**

    {lang=js}
    ~~~~~~~
    var agora = new Date();
    agora.toISOString();
    agora.toUTCString();
    ~~~~~~~

- ***[.toLocaleString()](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Date/toLocaleString)***

    Devolve unha cadea coa data en versión local. Se queres un idioma/rexión específica deberás recorrer a *[Lista de códigos IETF](http://www.iana.org/assignments/language-subtag-registry/language-subtag-registry)*.

    Tamén permite unha configuración detallada.

    {lang=js}
    ~~~~~~~
    var agora = new Date();
    console.info(agora.toLocaleString());

    // Código de idioma IETF pra Alemán
    console.info(agora.toLocaleString("de-DE"));

    // Opcións Avanzadas pra datas
    var opcions = {
        weekday: 'long',
        year: 'numeric',
        month: 'long',
        day: 'numeric'};
    console.log(agora.toLocaleString("de-DE", opcions));
    ~~~~~~~

## ***[Benchmark](https://es.wikipedia.org/wiki/Benchmark_(inform%C3%A1tica))***

Agora que xa sabemos manexar o tempo, facilmente poderemos facer probas básicas de rendemento.

Poderemos crear unha primeira data antes de executar certo código e outra xusto ao final do mesmo pra así comparar o tempo transcorrido.

[As probas de rendemento (benchmarks)](https://es.wikipedia.org/wiki/Benchmark_(inform%C3%A1tica)), poden ser de grande axuda pra tomar decisións importantes a hora de refactorizar o noso código.

{lang=js}
~~~~~~~
var inicio = new Date();
    // Código a testear
var fin = new Date();
var transcurso = fin.getTime() - inicio.getTime();
console.info("Pasaron "+transcurso+"ms");
~~~~~~~


I> **Recorda**
I>
I> Pódense realizar probas de rendemento coa consola do navegador (*[console.time()](https://developer.mozilla.org/en-US/docs/Web/API/Console/time)* y
I> *[console.timeEnd()](https://developer.mozilla.org/en-US/docs/Web/API/Console/timeEnd)*), como
I> vimos no capítulo 3.


## Setters, problema resolto

I> **Usa librerías**
I>
I> Lidiar coas datas é unha tarefa complexa. Se vas a usar librerías, podes saltarte o resto do capítulo sen ningún problema.

Como vimos antes, en ocasións desexamos poder sumar 56 días a data actual. Se utilizamos só os *setters*, JavaScript estimará datas seguramente erróneas. Pra asegurarnos que estamos sumando e restando as cantidades correctas, o ideal é sempre incluír o *getter* correspondente dentro do *setter*.

Vexamos a continuación o uso de getters pra modificar datas (días, meses, etc...).

Nota: Partindo do *[exemplo de MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/setDate)*.

### Sen *getters*

{lang=js}
~~~~~~~
var theBigDay = new Date(1962, 6, 7);
theBigDay.toLocaleString(); // 6/7/1962 23:00:00

var theBigDay = new Date(1962, 6, 7);
theBigDay.setDate(24);
theBigDay.toLocaleString() // 23/7/1962 23:00:00

var theBigDay = new Date(1962, 6, 7);
theBigDay.setDate(32);
theBigDay.toLocaleString() // 31/7/1962 23:00:00

var theBigDay = new Date(1962, 6, 7);
theBigDay.setDate(22);
theBigDay.toLocaleString() // 21/7/1962 23:00:00

var theBigDay = new Date(1962, 6, 7);
theBigDay.setDate(22 + 32 +24);
theBigDay.toLocaleString() // 15/9/1962 23:00:00
~~~~~~~

{pagebreak}


### Con *getters*

{lang=js}
~~~~~~~
var theBigDay = new Date(1962, 6, 7);
theBigDay.toLocaleString(); // 6/7/1962 23:00:00

var theBigDay = new Date(1962, 6, 7);
theBigDay.setDate(theBigDay.getDate() + 24);
theBigDay.toLocaleString(); // 30/7/1962 23:00:00

var theBigDay = new Date(1962, 6, 7);
theBigDay.setDate(theBigDay.getDate() + 32);
theBigDay.toLocaleString(); // 7/8/1962 23:00:00

var theBigDay = new Date(1962, 6, 7);
theBigDay.setDate(theBigDay.getDate() + 22);
theBigDay.toLocaleString(); // 28/7/1962 23:00:00

var theBigDay = new Date(1962, 6, 7);
theBigDay.setDate(theBigDay.getDate() + 22 + 32 + 24);
theBigDay.toLocaleString(); // 22/9/1962 23:00:00
~~~~~~~
