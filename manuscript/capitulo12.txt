# Capítulo 12 - AJAX é máis AJAX

{:: encoding="utf-8" /}
{footnotes-off}

## Entendendo HTTP/s

Http *(Hypertext Transfer Protocol)* é un protocolo de comunicación que utilizamos no noso día a día. Unha das súas características chave é que non *[mantén o estado](https://es.wikipedia.org/wiki/Protocolo_sin_estado)*, que ocasiona que teñamos que buscar alternativas para isto como as *[cookies](https://en.wikipedia.org/wiki/HTTP_cookie)*, *[localStorage](https://developer.mozilla.org/es/docs/DOM/Almacenamiento)*, etc...

Como curiosidade a versión máis utilizada deste protocolo é a 1.1 de 1999, anque recentemente, temos xa liberada a versión 2 que inclúe moitas melloras no empaquetamento e transporte da información.

A parte chave a hora de entender este protocolo, é que segue un esquema petición-resposta entre cliente e servidor, que fai que teñamos que refrescala páxina pra poder recibir a nova información. Tal como funcionaba a web a principios do dous mil...

Se nos adentramos un pouco máis, veremos que esa peticion-resposta, basicamente componse de mensaxes cunha estrutura moi determinada.


Líña inicial

: Na petición especificase o método utilizado.

: Na resposta especificase un código de resposta.


Cabeceira

: Poderemos encontrar tódolos metadatos propios da petición e a resposta.


Corpo

: Esta parte é opcional e conten por exemplo html, css... textos planos, o que sexa en si a mensaxe dende o servidor, así como dende o cliente.


### Métodos

Cando navegamos pola web utilizando o navegador por defecto, sempre estamos facendo uso do método *GET*, pero existen gran cantidade de métodos cos que poder facer as peticións.

Isto é importante, xa que dende as peticións AJAX poderemos especificar o método que utilizaremos, co que se estamos traballando cunha API REST, veremos que existe certa "correlación" entre as rutas e os métodos usados.

Os métodos máis utilizados son *GET*, *POST (típico de formularios)*, *PUT* y *DELETE*.


### Códigos de erro

Cando chéganos a resposta do servidor, sempre ven acompañada dun código numérico que nos confirma o resultado da petición, por exemplo, o *[mítico error 404](https://www.genbeta.com/web/error-404-not-found-historia-y-hazanas-de-este-mitico-codigo)*, que nos encontramos en multitude de ocasións navegando pola rede.

Estes códigos de estado poden dividirse en cinco categorías principais:

- 1xx **Informativas**.
- 2xx **Peticións Correctas**.
- 3xx **Redireccións**.
- 4xx **Erros Cliente**.
- 5xx **Erros Servidor**.

Sendo especialmente importantes pra nos, os 4xx e os 5xx, xa que nos indican erros que están sucedendo e isto seguramente derive nun tráfico de datos erróneo.


I> Aquí poderedes encontrala *[lista completa](https://es.wikipedia.
I> org/wiki/Anexo:C%C3%B3digos_de_estado_HTTP)* e a *[especificación](https://tools.ietf.
I> org/html/rfc2616#section-10)*.


W> **Misterioso estado 418**
W>
W> Existen algúns códigos tan incribles como *[418. I´m a teapot](http://www.josevazquez.net/codigo
W> -de-estado-http-418-i%C2%B4m-a-teapot/)*.


## Traballando con APIs

É innegable que cada día é máis popular, escoitar términos como *API*, *API REST*... isto debese a la maneira de facer a web hoxe en día, cun gran desacoplamento do cliente e o servidor, que permite a un mesmo backend, dar soporte a múltiples solucións de front, xa sexan web, móbiles, *[Internet Of Things (IoT)](https://es.wikipedia.org/wiki/Internet_de_las_cosas)*... e incluso outros backends.

Pra facer que todo isto flúa, é necesario comprender que xogan moitos factores chaves como:

- ***[API](https://es.wikipedia.org/wiki/Interfaz_de_programaci%C3%B3n_de_aplicaciones)***
- ***[REST](https://es.wikipedia.org/wiki/Transferencia_de_Estado_Representacional)***
- ***[SOAP](https://es.wikipedia.org/wiki/Simple_Object_Access_Protocol)***


Normalmente no mundo da web cando referímonos a unha API, case sempre falamos dunha API REST, que permítenos a través dunha serie de urls é seguindo unha *[metodoloxía CRUD](https://www.wikiwand.com/es/CRUD)*, traballar cun backend dende o cliente.

Isto permite conseguir datos (peticións GET), actualizar datos (peticións PUT), crear novos datos (peticións POST) e eliminar datos (peticións Delete).

Na maioría dos casos, o intercambio de información entre o cliente e o servidor realizase utilizando un formato de intercambio de datos coñecido como JSON e non XML como antigamente. De todo isto falaremos ao longo deste último capítulo.


I> Pra ilustrar un pouco o exemplo, invítote a visitar *[jsonplaceholder](https://jsonplaceholder.
I> typicode.com/)* que é unha especie de *[Lorem Ipsum](https://es.wikipedia.org/wiki/Lorem_ipsum)*
I> pra peticións Ajax.


Supoñamos que o noso backend é un blog, e queremos crear, ler, actualizar e borrar posts. A nosas rutas serían algo así:

Petición GET a *api.loremblog.com/posts*

: Devólvenos un JSON con tódolos post dispoñibles.


Petición POST a *api.loremblog.com/posts*

: Créanos unha nova entrada na base de datos, cos datos en JSON que lle pasamos.


Petición PUT a *api.loremblog.com/posts/hello*

: Permítenos actualizala entrada (numero/nome hello) cos datos JSON que lle pasamos.


Petición DELETE a *api.loremblog.com/posts/hello*

: Permítenos borrala entrada (numero/nome hello).


I> Partindo desta filosofía, poderemos atrevernos con moitas APIs, tan divertidas como [Twitter](
I> https://dev.twitter.com/), *[Facebook](https://developers.facebook.com/)*, *[Spotify](https://
I> developer.spotify.com/web-api/)* e incluso *[Yahoo!](https://developer.yahoo.com/everything.html)*



## Peticións AJAX

Xa vimos que as peticións Ajax son a esencia na web de hoxe, pero sempre que as utilicemos, debemos recordar, que nos somos consumidores/xeradores de datos é que a nosa aplicación, esta dependendo de maneira permanente de outros sistemas.

Isto quere dicir, que pode haber errores no seu código, que fagan que as respostas as nosas peticións non traian os datos como esperamos. Por tanto, teremos que facer un esforzo adicional pra validar tódolos datos que recibimos. En ocasións a documentación sobre a API, pode ser pouco precisa o estar desfasada... deixándonos nunha situación moi comprometida.

Pero a maioría de servizos grandes ou empresas que orientan súas liñas de negocio ao API soen dar un bo servizo. Recordade tamén que existen APIs de pago. En ocasións isto pode resultar complicado, se estamos desenvolvendo, temos que facer moitas consultas e se dispón de pouco presuposto.

Nos recomendamos, crear un sistema de arquivos JSON que almacene certos datos estáticos, que sexan iguais ou moi similares aos que esperamos recibir da API. Así poderemos maquetar e desenvolver sen consumir realmente chamadas. Isto é especialmente útil, pra sistemas moi caros como APIs de *Intelixencia Artificial como Servizo (AIaaS)*.

![Imaxe de CommitStrip.com](images/ajax-loop.jpg)

### Erros máis comúns (por código)

Referimos a continuación unha lista dos erros máis comúns, e de algunhas solucións cando non encontramos moita documentación dispoñible sobre unha API en concreto.

Resposta 200

: *OK*. Este é o código esperado... é todo marcha ben.


Resposta 204

: *Sen contido*. Non enviámolos datos, pero a petición resultou éxitosa, seguramente con datos por defecto.


Resposta 401

: *Non autorizado*. Esquecemos utilizalo token. O noso token non esta correctamente configurado.


Resposta 403

: *Prohibido*. Non temos o token/acceso correcto. Pode ser que intentemos modificar elementos que non sexan da nosa competencia, como a configuración de outros usuarios, etc...


Resposta 404

: *No encontrado*. Apuntamos a unha ruta que non existe. Revisa a documentación.


Resposta 409

: *Conflito, xa existe*. Intentamos crear dúas veces o mesmo elemento, isto soe pasar se realizamos unha dobre chamada Ajax, por erro. Típico de peticións *POST*.


### *[JSON](http://www.wikiwand.com/es/JSON)*

Antes de realizar a nosa primeira chamada Ajax, vexamos como traballar con JSON.

Para a visualización, validación e conversión dinámica de datos contamos con algunha ferramentas moi útiles.

- *[JSONLint](http://jsonlint.com/)*
- *[JSON Formatter & Validator](https://jsonformatter.curiousconcept.com/)*
- *[Online JSON Viewer](http://jsonviewer.stack.hu/)*
- *[JSON Editor](http://braincast.nl/samples/jsoneditor/)*

I> É importante recordar que algunhas respostas JSON, poden conter ata varios megas de
I> información.
I> Necesitaras ferramentas de visualización adicionais máis ala da consola do teu
I> navegador.

O navegador apórtanos dúas formas básicas de interactuar con datos JSON.

- ***[JSON.parse()](https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/JSON/parse)***

    Que analiza a cadea JSON, validándoa e retornando os valores como un dato válido de JavaScript. O máis habitual é un obxecto ou array.

    {lang=js}
    ~~~~~~~
    var objeto = JSON.parse('{"test": true}');
    var lista = JSON.parse('[true, "NO", 23]');
    var booleano = JSON.parse('false');
    var texto = JSON.parse('"cadea!"');
    ~~~~~~~

- ***[JSON.stringify()](https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/JSON/STRINGIFY)***

    Analiza os valores é retorna unha cadea en formato JSON.

    {lang=js}
    ~~~~~~~
    var objetoJSON = JSON.stringify({"test": true});
    var listaJSON = JSON.stringify([true, "NO", 23]);
    var booleanoJSON = JSON.stringify(false);
    var textoJSON = JSON.stringify("cadea!");
    ~~~~~~~


### Peticións

A mecánica das peticións é realmente sinxela. Simplemente necesitamos saber a que URL vamos a realizar a petición, que método vamos a utilizar (GET, POST, PUT o DELETE) e con que función (callback) manexaremos os datos de volta.

I> Loxicamente las peticións Ajax son asíncronas por natureza. Si aínda tes dubidas, sobre os
I> callbacks e o manexo da sincronía, este é un gran momento pra retroceder ao capítulo
I> anterior e repasar eses conceptos antes de seguir.

Se estades familiarizados con JQuery, as peticións Ajax son algo moi trivial, gracias a *[jQuery.ajax()](http://api.jquery.com/jquery.ajax/)*. Vexamos o seguinte exemplo:


{lang=js}
~~~~~~~
$.ajax({
    dataType: "json",
    url: "<---URL---->",
})
 .done(function( data, textStatus, jqXHR ) {
     console.log( "A solicitude completouse correctamente." );
     console.log( data );
 })
 .fail(function( jqXHR, textStatus, errorThrown ) {
      console.log( "A solicitude fallou: " +  textStatus);
});
~~~~~~~

### Non recargamos pero somos asíncronos.

![Imaxe de gemsres.com](images/ajax.jpg)

Como podes ver, xa non é necesario recargala páxina como antes, xa que o navegador se encargase de facer a petición é xestionala nun segundo plano. Agora veremos como se fai con *[Vanilla.js](http://vanilla-js.com/)*, verás que realmente entendese mellor o proceso e parece menos *máxico* que con JQuery.


#### Falaremos de *[XMLHttpRequest](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest)*

Pra poder realizar peticións Ajax, de maneira nativa, os navegadores implementan un obxecto dende o que poderemos realizalas peticións, chamado *[XMLHttpRequest](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest)*.

Ten os seus propios eventos:



- *[loadstart](https://developer.mozilla.org/en-US/docs/Web/Events/loadstart)*
- *[progress](https://developer.mozilla.org/en-US/docs/Web/Events/progress)*
- *[abort](https://developer.mozilla.org/en-US/docs/Web/Events/abort)*
- *[error](https://developer.mozilla.org/en-US/docs/Web/Events/error)*
- *[load](https://developer.mozilla.org/en-US/docs/Web/Events/load)*
- *[timeout](https://developer.mozilla.org/en-US/docs/Web/Events/timeout)*
- *[loadend](https://developer.mozilla.org/en-US/docs/Web/Events/loadend)*
- *[readystatechange](https://developer.mozilla.org/en-US/docs/Web/Events/readystatechange)*

E os seus propios estados de petición:

- 0 *uninitialized*
- 1 *loading*
- 2 *loaded*
- 3 *interactive*
- 4 *complete*

Mellor vexamos como funciona cun exemplo real e logo explicamos como xestionar algo que parece tan complexo, pero que realmente é sinxelo.

Pra este exemplo decidimos traelos datos da *[película Hackers](http://www.imdb.com/title/tt0113243/)*, que ademais vos *[recomendo ver](http://www.imdb.com/videoplayer/vi2444991257?ref_=tt_pv_vi_aiv_1)*.

Para isto utilizaremos *[OMBd Api](https://www.omdbapi.com/)*... unha vez lida a documentación, saberemos que só necesitamos apuntar a esta url, *[http://www.omdbapi.com/?t=Hackers&y=&plot=short&r=json](http://www.omdbapi.com/?t=Hackers&y=&plot=short&r=json)*.

{lang=js}
~~~~~~~
var url = "http://www.omdbapi.com/?t=Hackers&y=&plot=short&r=json";
var xmlHttp = new XMLHttpRequest();

xmlHttp.onreadystatechange = function() {

    if (xmlHttp.readyState === 4)
       if(xmlHttp.status === 200) {
          console.info(JSON.parse(xmlHttp.responseText));
       } else if (xmlHttp.status === 404) {
          console.error("ERROR! 404");
          console.info(JSON.parse(xmlHttp.responseText));
    }
};
xmlHttp.open("GET", url, true);
xmlHttp.send();
~~~~~~~

Vendo o código é moito máis sinxelo...

**Vamos por pasos:**

1. *Liña 1:* Primeiro definimos a URL.
2. *Liña 2:* Logo instanciamos *XMLHttpRequest*, igual que facíamos con *Date* en capítulos anteriores.
3. *Liña 4:* Cada vez que cambiemos de estado na nosa petición Ajax, o navegador executará *xmlHttp.onreadystatechange* .
    1. *Liña 6:* Filtramos polo *xmlHttp.readyState*, e esperamos ao 4 (completado).. obviando todo o demais.
    2. *Liña 7:* Unha vez confirmamos que se terminou toda a xestión de Ajax, pasamos a analizalos datos recibidos. Filtrando por código de estado con *xmlHttp.status*, e parseando ou alertando ao usuario do erro na función das circunstancias.
4. *Liña 14:* Abrimos a petición coa url e o método desexado.
5. *Liña 15:* Executamos a petición.


### *[CORS](https://developer.mozilla.org/es/docs/Web/HTTP/Access_control_CORS)*

Un problema clásico a ter en conta é a posibilidade de que *[CORS](https://developer.mozilla.org/es/docs/Web/HTTP/Access_control_CORS)*, non este habilitado no servidor.

*[CORS](https://developer.mozilla.org/es/docs/Web/HTTP/Access_control_CORS)* basicamente, é un parámetro que envíase dende as cabeceiras HTTP do servidor e permítenos realizar peticións AJAX. Existen algúns sitios web, que a pesar de ter, unha API funcionando non habilitaron esa configuración:

{lang=text}
~~~~~~~
"Access-Control-Allow-Origin", "*"
"Access-Control-Allow-Headers", "Origin, X-Requested-With, Content-Type, Accept"
~~~~~~~

E por isto, calquera petición que fagamos dende o navegador cliente non poderá realizarse.

A mellor solución, é comunicarnos cos responsables da API e facilitarlles *[este link](http://enable-cors.org/index.html)*, onde *[Monsur Hossain](http://monsur.hossa.in/)* y *[Michael Hausenblas](http://mhausenblas.info/)*, explican como realizalas configuracións adecuadas en moitos entornos.

Se por desgracia esta opción esta descartada, non pasa nada.... existen máis posibilidades.

A primeira é máis útil é crear/configurar/usar un *[proxy](https://es.wikipedia.org/wiki/Servidor_proxy)*. A idea do proxy, é que realice unha petición capturando eses datos e enviándoos de novo, tendo CORS habilitado na cabeceira, de tal forma que poderemos facer peticións Ajax, anque teñamos que pasar polo noso servidor.

Loxicamente plantexasenos un problema de tráfico, no noso servidor é unha lentitude nas nosas peticións, pero al menos poderemos facer as peticións.

I> Antes de configurar un proxy, podes usar *[Crossorigin](http://crossorigin.me/)* pra prototipar
I> -é un *[proxecto Open Source](https://github.com/technoboy10/crossorigin.me)*- e poderás
I> adaptalo facilmente as túas necesidades.
