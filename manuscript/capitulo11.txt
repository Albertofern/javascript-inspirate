-# Parte III - Web dinámica e conectada...

# Capítulo 11 - Hackeando HTML e CSS

{:: encoding="utf-8" /}
{footnotes-off}

![Imaxen obtida de javascript.info](images/arbol.png)

A hora de traballar co navegador fora da consola, dispoñemos basicamente de tres alicerces:


JavaScript

: Que é o que intentamos aprender ao longo deste libro, e que nos permite en esencia programar sobre a web que esta renderizada no cliente.


BOM

: *Browser Object Model*, que conten navigator, *[history](https://developer.mozilla.org/es/docs/Web/API/history)*, *[screen](https://developer.mozilla.org/es/docs/Web/API/screen)*, *[location](https://developer.mozilla.org/es/docs/Web/API/Location)*, *[XMLHttpRequest](https://developer.mozilla.org/es/docs/XMLHttpRequest)*, etc... os cales son fillos de *[window](https://developer.mozilla.org/pl/docs/Web/API/Window)*.


DOM

: *[Document Object Model](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model)*, é unha interface pra HTML, CSS e SVG que nos facilita unha representación en forma de árbore sobre a que poderemos traballar con JavaScript.


## BOM (Browser Object Model)

É unha recopilación dos compoñentes máis utilizados, anque existen algúns máis.


### *[window.history](https://developer.mozilla.org/es/docs/Web/API/History)*

Permítenos manipulalo historial da sesión actual, iso inclúe soamente as páxinas visitadas coa pestana actual.

Podemos averiguala cantidade de páxinas visitadas previamente, facendo uso da propiedade *[length](https://developer.mozilla.org/en-US/docs/Web/API/History/length)*.

{lang=js}
~~~~~~~
history.length
~~~~~~~

Tamén podemos realizar accións, como mandar ao usuario a paxina inmediatamente seguinte co método *[forward](https://developer.mozilla.org/es/docs/DOM/Manipulando_el_historial_del_navegador)*, a anterior co *[back()](https://developer.mozilla.org/es/docs/DOM/Manipulando_el_historial_del_navegador)* ou directamente a calquera posición do historial con *[go()](https://developer.mozilla.org/es/docs/DOM/Manipulando_el_historial_del_navegador)*.


{lang=js}
~~~~~~~
// Ir atrás
history.go(-1);
history.back();

// Ir adelante
history.go(1);
history.forward();
~~~~~~~


### *[window.navigator](https://developer.mozilla.org/es/docs/Web/API/Navigator)*


É unha API que permítenos sacar gran cantidade de información sobre a máquina onde se esta executando o noso script. Incluso dispón de algúns métodos tan interesantes como *[Navigator.vibrate()](https://developer.mozilla.org/es/docs/Web/API/Navigator/vibrate)*, que permite facer vibrar o dispositivo (sempre que sexa compatible).

No seguinte exemplo, facemos unha lectura de gran información do sistema e ademais facemos un par de cálculos interesantes pra confirmar o nivel de batería.

Na liña 28 utilizamos unha *[promesa](https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Promesa)*, xa que *[navigator.getBattery()](https://developer.mozilla.org/es/docs/Web/API/Navigator/getBattery) o require así. Recorda que esta é outra das formas válidas, que existen pra manexar a asincronía.*




{lang=js}
~~~~~~~
function conversorTiempo(segundos){
	var data = new Date(segundos * 1000);
	var hh = data.getUTCHours();
	var mm = data.getUTCMinutes();
	var ss = data.getSeconds();

	if (hh < 10) {hh = "0"+hh;}
	if (mm < 10) {mm = "0"+mm;}
	if (ss < 10) {ss = "0"+ss;}

	return hh+":"+mm+":"+ss;
}

function informacionSistema(){
	console.log("appCodeName:", window.navigator.appCodeName);
	console.log("appName:", window.navigator.appName);
	console.log("appVersion:", window.navigator.appVersion);
	console.log("platform:", window.navigator.platform);
	console.log("product:", window.navigator.product);
	console.log("userAgent:", window.navigator.userAgent);
	console.log("javaEnabled:", window.navigator.javaEnabled());
	console.log("language (used):", window.navigator.language);
	console.log("language (support):", window.navigator.languages);
	console.log("conectado a internet?", window.navigator.onLine);
	console.log("mimeTypes:",window.navigator.mimeTypes);
	console.log("Plugins:", navigator.plugins);

	navigator.getBattery().then(function(bateria){
		console.log("Batería cargando?", bateria.charging)

		if(bateria.charging){
			console.log("Tempo de carga:", bateria.chargingTime)
		}
		console.log("Batería %:", bateria.level*100)
		console.log("Tempo restante:", conversorTiempo(bateria.dischargingTime))
	});

}
~~~~~~~



### *[window.screen](https://developer.mozilla.org/en-US/docs/Web/API/Screen)*

Esta API permítenos sacar toda a información dispoñible da pantalla (marxes, profundidade do color...), así poderemos bloquear e desbloquear a rotación da pantalla no dispositivo.


{lang=js}
~~~~~~~
console.log("availTop:", window.screen.availTop);
console.log("availLeft:", window.screen.availLeft);
console.log("availHeight:", window.screen.availHeight);
console.log("availWidth:", window.screen.availWidth);
console.log("colorDepth:", window.screen.colorDepth);
console.log("height:", window.screen.height);
console.log("left:", window.screen.left);
console.log("orientation:", window.screen.orientation);
console.log("pixelDepth:", window.screen.pixelDepth);
console.log("top:", window.screen.top);
console.log("width:", window.screen.width);
~~~~~~~

{pagebreak}

### *[Window.location](https://developer.mozilla.org/es/docs/Web/API/Window/location)* y *[Document.location](https://developer.mozilla.org/es/docs/Web/API/Document/location)*

*[Segundo a W3C](https://www.w3.org/TR/html/browsers.html#dom-location)* ambos obxectos son o mesmo.

### Propiedades

{lang=js}
~~~~~~~
var enlace = document.createElement('a');
enlace.href = 'https://leanpub.com/javascript-inspirate';

console.log("href:" ,enlace.href);
console.log("protocol:", enlace.protocol);
console.log("host:", enlace.host);
console.log("hostname:", enlace.hostname);
console.log("port:", enlace.port);
console.log("pathname:", enlace.pathname);
console.log("search:", enlace.search);
console.log("hash:", enlace.hash);
console.log("origin:", enlace.origin);
~~~~~~~




### Métodos:

- ***[.assign()](https://developer.mozilla.org/en-US/docs/Web/API/Location/assign)***

	Carga una nova páxina.

	{lang=js}
	~~~~~~~
	document.location.assign('https://leanpub.com/javascript-inspirate');
	~~~~~~~

- ***[.reload()](https://developer.mozilla.org/en-US/docs/Web/API/Location/reload)***

	Recarga a páxina actual con opcións pra manexar o cacheado.

	{lang=js}
	~~~~~~~
	// Recarga
	document.location.reload();

	// Recarga sen usar o cache
	document.location.reload(true);
	~~~~~~~

- ***[.replace()](https://developer.mozilla.org/en-US/docs/Web/API/Location/replace)***

	Carga unha páxina nova, substituíndo a actual no historial.

	{lang=js}
	~~~~~~~
	document.location.replace('https://leanpub.com/javascript-inspirate');
	~~~~~~~


## *[DOM](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model)*

Vexamos como entende a comunidade *[MDN (Mozilla Developer Network)](https://developer.mozilla.org)* o concepto *[DOM - Document Object Model](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model)*.

{icon=quote-left}
G> O modelo de obxecto de documento (DOM) é unha interface de programación pra os documentos HTML
G> e XML. Facilita unha representación estruturada do documento e define de que maneira os
G> programas poden acceder, co fin de modificar, tanto a súa estrutura, estilo e contido. O
G> DOM da unha representación do documento como un grupo de nodos e obxectos estruturados que
G> teñen propiedades e métodos. Esencialmente, conecta as páxinas web a scripts ou a linguaxes de
G> programación.
G>
G> Unha páxina web é un documento. Este documento pode exhibirse na venta dun navegador ou
G> tamén como código fonte HTML. Pero, nos dous casos, é o mesmo documento. O modelo de
G> obxecto de documento (DOM) proporciona outras formas de presentar, gardar e manipular este mesmo
G> documento. O DOM é unha representación completamente orientada ao obxecto da páxina web e
G> pode ser modificado cunha linguaxe de script como JavaScript.


Nos cremos que o DOM é patio de xogos de calquera desenvolvente que se precie. Tanto se fas frontend e o utilizas pra mostrar información dinamicamente como se estás no backend e o utilizas pra *[scrapear](https://es.wikipedia.org/wiki/Web_scraping)*.

A os ollos de JavaScript o DOM é un obxecto co que poderemos ler e modificar ao noso antollo. Unha vez se comprende con claridade a estrutura de nodos que o compón e os seus métodos principais, está dominado.


### Selectores

O primeiro paso pra poder manipular o DOM, é adquirir certa destreza no manexo dos selectores, xa que sempre os selectores serán o primeiro paso, pra realizar operacións de lectura ou modificación do DOM.

É importante remarcar, que certos métodos pra realizar selección de compoñentes, sofren do mesmo problema que vimos en *arguments*, xa que anque parecen *arrays*... realmente non o son.

Estes métodos son:

- *[Node.childNodes](https://developer.mozilla.org/es/docs/Web/API/Node/childNodes)*
- *[document.querySelectorAll](https://developer.mozilla.org/es/docs/Web/API/Document/querySelectorAll)*

I> #### Podemos convertelos facilmente:
I>
I> {lang=js}
I> ~~~~~~~
I> var listaDivs = document.querySelectorAll('div');
I> // Conversión
I> var listaDivsArray = Array.prototype.slice.call(listaDivs);
I> ~~~~~~~
I>
I> Máis información sobre a conversión en [Convert NodeList to Array de David Walsh](https://
I> davidwalsh.name/nodelist-array).

### Selectores tradicionais

- ***[.getElementById()](https://developer.mozilla.org/es/docs/Web/API/Document/getElementById)***

	Permite a selección dun elemento polo seu *[id](https://developer.mozilla.org/es/docs/Web/HTML/Atributos_Globales/id)*.

    {lang=js}
	~~~~~~~
    // <div id="miDiv"></div>
    document.getElementById("miDiv");
    ~~~~~~~

- ***[.getElementsByName()](https://developer.mozilla.org/es/docs/Web/API/Document/getElementsByName)***

	Permite a selección de varios elementos polo seu atributo *[name](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes)*.

    {lang=js}
	~~~~~~~
    // <form name="miForm"></form>
    document.getElementsByName("miForm");
	~~~~~~~



- ***[.getElementsByTagName()](https://developer.mozilla.org/es/docs/Web/API/Document/getElementsByTagName)***

	Permite a selección de varios elementos pola súa *[etiqueta](https://developer.mozilla.org/es/docs/Web/HTML/Elemento)*.

    {lang=js}
	~~~~~~~
    // <input>
    document.getElementsByTagName("input");
	~~~~~~~

- ***[.getElementsByClassName()](https://developer.mozilla.org/es/docs/Web/API/Document/getElementsByClassName)***

	Permite a selección de varios elementos pola súa *[clase](https://developer.mozilla.org/es/docs/Web/HTML/Atributos_Globales/class)*.

    {lang=js}
	~~~~~~~
    // <div class="vermello"></div>
    document.getElementsByClassName("vermello");
    ~~~~~~~

### Selectores Avanzados

{icon=coffee}
G> #### Lecturas recomendadas:
G>
G> - *[Os 30 selectores CSS que debes memorizar](https://code.tutsplus.com/es/tutorials/the-30-css-selectors-you-must-memorize--net-16048)*
G> - *[Selectors Level 3 - W3C](https://www.w3.org/TR/css3-selectors/)*
G> - *[CSS Cheat Sheet](http://www.cheetyr.com/css-selectors)*
G> - *[Taming Advanced CSS Selectors by Inayaili de Leon](https://www.smashingmagazine.com/2009/08/taming-advanced-css-selectors/)*
G> - *[Selectors en MDN](https://developer.mozilla.org/es/docs/Web/CSS/Introducci%C3%B3n/Selectors)*
G> - *[CSS Selector Reference by w3schools](http://www.w3schools.com/cssref/css_selectors.asp)*
G> - *[CSS Selectors by Adam Roberts](https://www.sitepoint.com/web-foundations/css-selectors/)*
G> - *[CSS-TRICKS Selectors](https://css-tricks.com/almanac/selectors/)*
G> - *[Interactive CSS Selectors by Ben Howdle](http://benhowdle.im/cssselectors/)*

Se traballaches intensamente con CSS3 xa saberás que existen moitas posibilidades pra realizar seleccións dentro dun documento html que van moito máis ala da clase, id, etiqueta ou propiedades, xa que *[o soporte](http://caniuse.com/#feat=css-sel3)* pra elo es moi bon en tódolos navegadores.

JavaScript non se queda atrás e pódense usar *[querySelector](https://developer.mozilla.org/es/docs/Web/API/Document/querySelector)* y *[querySelectorAll](https://developer.mozilla.org/es/docs/Web/API/Document/querySelectorAll)*  que ademais gozan dun gran *[soporte](http://caniuse.com/#search=querySelector)*.


Vexamos como se utilizan algúns selectores avanzados de CSS3:




- URL que empezan con "javascript:"

    {lang=css}
	~~~~~~~
    a[href^="javascript:"] {
    	color:blue;
    }
	~~~~~~~

- URL que conten "google.es"

    {lang=css}
	~~~~~~~
    a[href*="leanpub"] {
    	color:orange;
    }
	~~~~~~~

- URL que rematan con ".pdf"

    {lang=css}
	~~~~~~~
    a[href$=".pdf"] {
    	color:red;
    }
	~~~~~~~

{pagebreak}

#### *[.querySelector()](https://developer.mozilla.org/es/docs/Web/API/Document/querySelector)*

Devolve o primeiro elemento que coincida co selector.

{lang=html}
~~~~~~~
<div id="meuDiv">
    <span id="meuId5" class="miñaClase" title="cinco"></span>
    <span id="meuId4" class="miñaClase" title="catro"></span>
    <span id="meuId3" class="miñaClase" title="tres"></span>
    <span id="meuId2" class="miñaClase" title="dous"></span>
    <span id="meuId1" class="miñaClase" title="un"></span>
</div>
~~~~~~~

{lang=js}
~~~~~~~
document.getElementById('meuId1').title // un
document.querySelector('#meuDiv .miñaClase').title // cinco
document.querySelector('#meuDiv #meuId1.miñaClase').title // un
document.querySelector('#meuDiv .inventado').title // ERROR -> undefined
document.querySelector('#meuDiv .miClase[title^=u]').title // un
~~~~~~~

#### *[.querySelectorAll()](https://developer.mozilla.org/es/docs/Web/API/Document/querySelectorAll)*

Devolve tódolos elementos que coincidan co selector nun pseudo-array.

{lang=js}
~~~~~~~
document.querySelectorAll('p') // os parágrafos
document.querySelectorAll('div, img') // divs e imaxes
document.querySelectorAll('a > img') // imaxes contidas en enlaces
~~~~~~~



### Estilos con Javascript

JavaScript tamén pode ler e alterar as regras de estilo, que afectan a los elementos que compoñen o DOM.

**Ler valores**

{lang=js}
~~~~~~~
window.getComputedStyle(document.getElementById("id"));
window.getComputedStyle(document.body).getPropertyValue('display');
~~~~~~~

**Cambiar valores**

{lang=js}
~~~~~~~
document.body.style.display="none";
document.getElementById("id").style.display="none";
~~~~~~~

{pagebreak}


## Alterando o DOM

### Traballar sen JQuery

Si levas moito tempo traballando con JQuery, sen duda, xa estás moi acostumado a utilizar certos métodos como *[show()](http://api.jquery.com/show/)*, *[hide()](http://api.jquery.com/hide/)*, *[empty()](http://api.jquery.com/empty/)*, *[append()](http://api.jquery.com/append/)* e moitos máis...

Pra facervos a transición máis fácil, *[HubSpot](http://product.hubspot.com/)* desenvolveu *[You Might Not Need Jquery](http://youmightnotneedjquery.com/)*, que te permite visualizar como facer todo o que facías con JQuery é que agora farás con JavaScript.

### Métodos esenciais

Facemos unha recompilación simplificada dos métodos máis utilizados, anque existen moitos máis.


- ***[.textContent](https://developer.mozilla.org/es/docs/Web/API/Node/textContent)***

	Devólvenos o texto dun elemento previamente seleccionado.

	{lang=js}
	~~~~~~~
	var el = document.getElementById('miDiv');
	console.log("Texto:", el.textContent);
	~~~~~~~

	Tamén permite cambialo.

	{lang=js}
	~~~~~~~
	var el = document.getElementById('meuDiv');
	el.textContent = "Novo contido";
	~~~~~~~

- ***[.classList.contains()](https://developer.mozilla.org/es/docs/Web/API/Element/classList)***

	Verifica se conten certa clase.

	{lang=js}
	~~~~~~~
	var el = document.getElementById('meuDiv');
	el.classList.contains("vermello");
	~~~~~~~


- ***[.classList.add()](https://developer.mozilla.org/es/docs/Web/API/Element/classList)***

	Permite engadir unha clase ao elemento.

	{lang=js}
	~~~~~~~
	var el = document.getElementById('meuDiv');
	el.classList.add("vermello");
	~~~~~~~

- ***[.classList.remove(className)](https://developer.mozilla.org/es/docs/Web/API/Element/classList)***

	Permite eliminar unha clase do elemento.

	{lang=js}
	~~~~~~~
	var el = document.getElementById('meuDiv');
	el.classList.remove("vermello");
	~~~~~~~

{pagebreak}

- ***[.style.display](https://developer.mozilla.org/es/docs/Web/API/HTMLElement/style)***

	Permítenos coñecer e modificar a visualización dun elemento concreto.

	{lang=js}
	~~~~~~~
	var el = document.getElementById('meuDiv');

	// Coñecer o estado actual
	console.log(el.style.display);

	// Non mostrar
	el.style.display = 'none';

	// Mostrar
	el.style.display = '';
	~~~~~~~



- ***[.cloneNode()](https://developer.mozilla.org/es/docs/Web/API/Node/cloneNode)***

	Permite clonar un nodo e clonar o non, os seus nodos fillo tamén.

	{lang=js}
	~~~~~~~
	var el = document.getElementById('miDiv');

	// Clon simple (sen fillos)
	var c1 = el.cloneNode();

	// Clon profundo (con fillos)
	var c2 = el.cloneNode(true);
	~~~~~~~

- ***[.innerHTML](https://developer.mozilla.org/es/docs/Web/API/Element/innerHTML)***
	Cambia ou devolve a séntese HTML dun elemento... así como dos seus fillos.

	{lang=js}
	~~~~~~~
	var el = document.getElementById('miDiv');
	// Ver o contido
	console.log("Contido:", el.innerHTML);

	// baleirar o contido
	el.innerHTML = '';

	// Substituír o contido
	el.innerHTML = 'Novo contido';
	~~~~~~~


- ***[.getAttribute()](https://developer.mozilla.org/es/docs/Web/API/Element/getAttribute)***

	Devolver o valor de certo atributo ou unha cadea baleira no caso de non existir.

	{lang=js}
	~~~~~~~
	var el = document.getElementById('fotoUsuario');
	el.getAttribute('src');
	~~~~~~~

- ***[.setAttribute()](https://developer.mozilla.org/es/docs/Web/API/Element/setAttribute)***

	Cambiar o valor dun atributo ou engádeo se non existe.

	{lang=js}
	~~~~~~~
	var el = document.getElementById('meuDiv');
	el.setAttribute('data-secreto', 'Moito...');
	~~~~~~~


## Eventos

Unha das maiores barreiras a hora de introducir o dinamismo nunha web é a xestión dos eventos, xa que estes son asíncronos por natureza, polo que non podes saber de antemán. Por exemplo, cantos segundos tardará un usuario en pinchar sobre un botón... o que sumado a un funcionamento peculiar con propagacións, fai que o dominio dos eventos sexa unha tarefa complicada.

I> Sen embargo, todo gran esforzo ten unha gran recompensa e o dominio destes eventos
I> abriranos portas a *[programación dirixida a eventos](https://es.wikipedia.
I> org/wiki/Programaci%C3%B3n_dirigida_por_eventos)*, é posteriormente a *[Node.js](https://
I> nodejs.org/en/)*, se decidimos dar o gran paso ata o *Back-End* ou o *Full Stack*.

### Funcionamento

Basicamente podemos seleccionar un elemento de HTML, e subscribir un dos posibles eventos dos que dispón:

- *[Eventos de rato](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent)*
- *[Eventos de teclado](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent)*
- E *[moitos máis...](https://developer.mozilla.org/es/docs/Web/Reference/Events)*

Unha vez definimos estes detalles, onde escoitamos e esperamos, so queda definir que faremos cando isto ocurra.

Loxicamente ao tratarse de asincronía, debemos definir unha función, xa sexa en liña ou reutilizable pra xestionalo todo.

Se necesitamos información adicional sobre o evento sucedido, o propio sistema mandará *[un obxecto con detalles chave sobre o evento](https://developer.mozilla.org/en-US/docs/Web/API/Event)*, como argumento a hora de executar o noso callback.



### Utilizando eventos

Existen dúas formas básicas de engadir eventos a nosa aplicación. Unha é por medio de html con atributos como *[onclick](https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XUL/Attribute/onclick)*, e a outra dende o JavaScript, facendo uso de métodos como *[.addEventListener()](https://developer.mozilla.org/es/docs/Web/API/EventTarget/addEventListener)*.

Cal é mellor ou cal é peor... realmente varia en función das circunstancias do código ou o seu desenvolvente. Eu creo firmemente, que é moito mellor separar JavaScript, HTML e CSS.

Así evitamos o *[antipatrón ](https://es.wikipedia.org/wiki/Antipatr%C3%B3n_de_dise%C3%B1o)* de mesturar JavaScript no HTML. Por outra parte, se encapsulas o teu código nunha función anónima autoexecutada, non poderás acceder as funcións directamente dende o HTML...

Así que por estes motivos principais, recomendamos encarecidamente o uso de *[.addEventListener()](https://developer.mozilla.org/es/docs/Web/API/EventTarget/addEventListener)*.


#### Engadir un evento

Vexamos como funciona co *onclick*.

{lang=html}
~~~~~~~
<body onclick="cambiarFondo()"></body>
~~~~~~~

{lang=js}
~~~~~~~
function cambiarFondo() {
	// cor = 'rgb(0-255,0-255,0-255)'
	var cor = 'rgb(' + Math.floor((Math.random() * 255))+ ',';
	cor += Math.floor((Math.random() * 255)) + ',';
	cor += Math.floor((Math.random() * 255)) + ')';
	document.body.style.backgroundColor= cor;
	console.info("Nova cor:", cor);
}
~~~~~~~

Vexamos como funciona con *[addEventListener()](https://developer.mozilla.org/es/docs/Web/API/EventTarget/addEventListener)*.

{lang=js}
~~~~~~~
document.body.addEventListener('click', function (e) {
    var cor = 'rgb(' + Math.floor((Math.random() * 255))+ ',';
    cor += Math.floor((Math.random() * 255)) + ',';
    cor += Math.floor((Math.random() * 255)) + ')';
    document.body.style.backgroundColor= cor;
    console.info("Nova cor:", cor);
});
~~~~~~~

#### Eliminar un evento

Os eventos ocupan memoria. É un factor a ter en conta, especialmente, se queremos facer unha web cun bo soporte pra smartphones. Se un evento deixa de ter sentido, sinxelamente podes eliminalo co *[.removeEventListener()](https://developer.mozilla.org/es/docs/Web/API/EventTarget/removeEventListener)*.

{lang=js}
~~~~~~~
function cambiarCor (){
    var cor = 'rgb(' + Math.floor((Math.random() * 255))+ ',';
    cor += Math.floor((Math.random() * 255)) + ',';
    cor += Math.floor((Math.random() * 255)) + ')';
    document.body.style.backgroundColor= cor;
    console.info("Nova cor:", cor);
}

document.body.addEventListener('click', cambiarCor);
document.body.removeEventListener('click', cambiarCor);
~~~~~~~

#### Manexadores de eventos

Cando se dispara un evento, podemos recopilar moita información útil, se non ignoramos o argumento que nos pasan.

Podemos facilmente crearnos unha función que nos aporte información real sobre o evento e que non execute ningunha acción na nosa aplicación. Este tipo de funciones son moi útiles e deberían estar no teu kit de ferramentas pra desenvolver webs como un artesán de verdade.

{lang=js}
~~~~~~~
function manexadorEventos(elEvento) {
  	// Compatibilizar el evento
  	var evento = elEvento || window.event;

  	// Imprimir detalles
  	console.log("-----------------------------")
  	console.log("Type: "+evento.type); // Tipo
  	console.log("Bubbles: "+evento.bubbles);
  	console.log("Cancelable: "+evento.cancelable);
  	console.log("CurrentTarget: ", evento.currentTarget);
	console.log("DefaultPrevented: "+evento.defaultPrevented);
	console.log("EventPhase: "+evento.eventPhase);
	console.log("Target: ", evento.target);
	console.log("TimeStamp: "+evento.timeStamp);
	console.log("IsTrusted: "+evento.isTrusted); // true - Usuario
	console.log("=============================")
}

// Añadimos Listener
document.addEventListener('click', function(evento){
	manejadorEventos(evento);
	// Más código
});
~~~~~~~

{pagebreak}

### Usos Avanzados

#### Lanzar un evento manualmente con [.dispatchEvent()]()

{lang=js}
~~~~~~~
document.body.addEventListener('click', function (e) {
    var cor = 'rgb(' + Math.floor((Math.random() * 255))+ ',';
    cor += Math.floor((Math.random() * 255)) + ',';
    cor += Math.floor((Math.random() * 255)) + ')';
    document.body.style.backgroundColor= cor;
    console.info("Nova cor:", cor);
});

var lanzadorEventos = new Event('click');
document.body.dispatchEvent(lanzadorEventos);
~~~~~~~

#### Compatibilidade co Internet Explorer <= IE8

Se tes a mala sorte de ter que dar soporte a versións obsoletas de Internet Explorer, ademais de todo o sufrimento acumulado, deberás engadirte unha carga extra... e que por aqueles tempos Internet Explorer, non era compatible con *[addEventListener()](https://developer.mozilla.org/es/docs/Web/API/EventTarget/addEventListener)*, nin con *[.removeEventListener()](https://developer.mozilla.org/es/docs/Web/API/EventTarget/removeEventListener)*, así que necesitamos utilizar *[.attachEvent()](https://developer.mozilla.org/es/docs/Web/API/EventTarget/attachEvent)* e *[.detachEvent()](https://developer.mozilla.org/es/docs/Web/API/EventTarget/detachEvent)*.


***[.attachEvent()](https://developer.mozilla.org/es/docs/Web/API/EventTarget/attachEvent)***

{lang=js}
~~~~~~~
document.attachEvent('onclick', function (e) {
    var cor = 'rgb(' + Math.floor((Math.random() * 255))+ ',';
    cor += Math.floor((Math.random() * 255)) + ',';
    cor += Math.floor((Math.random() * 255)) + ')';
    document.body.style.backgroundColor= cor;
    console.info("Nova cor:", cor);
});
~~~~~~~

***[.detachEvent()](https://developer.mozilla.org/es/docs/Web/API/EventTarget/detachEvent)***

{lang=js}
~~~~~~~
function cambiarCor (){
    var cor = 'rgb(' + Math.floor((Math.random() * 255))+ ',';
    cor += Math.floor((Math.random() * 255)) + ',';
    cor += Math.floor((Math.random() * 255)) + ')';
    document.body.style.backgroundColor= cor;
    console.info("Nova cor:", cor);
}

document.body.attachEvent('onclick', cambiarCor);
document.body.detachEvent('onclick', cambiarCor);
~~~~~~~

Dado este panorama de ter que usar dous métodos diferentes, cando ademais teñen unha estrutura similar, pero non idéntica... temos un reto entre as mans que merece unha solución duradeira.

Anque descartamos ensinar o uso de *[patróns](https://es.wikipedia.org/wiki/Patr%C3%B3n_de_dise%C3%B1o)*, sería injusto pola nosa parte non arroxar ao menos un pouco de luz sobre o asunto, así que gustaríanos mostrarte un par de trucos de *"artesán veterano"*.

Vamos a crear un obxecto (literal), onde gardaremos todo o necesario pra manexar eventos, subindo así o nivel de abstracción da vosa aplicación.

Xa non usaremos *.attachEvent()* o *.addEventListener()*. Agora utilizaremos *.engadir()*, que internamente chamará a *.attachEvent()* o *.addEventListener()*, en función do navegador no que nos atopemos.

Cambiar de navegador no medio da execución do script parece altamente improbable. Non tne moito sentido comprobar cada vez que agreguemos un evento, se usaremos *.attachEvent()* o *.addEventListener()*.

Por iso os patróns de deseño poden axudarnos a solucionar cousas así. Neste caso usaremos *Init-time branching*, que é unha variante de *[Lazy initialization](https://en.wikipedia.org/wiki/Lazy_initialization)*.

Basicamente crearemos un obxecto cos métodos *engadir* e *baleirar* baleiros. Ao executarse o código por vez primeira, comprobaremos que navegador usamos e en función de este sobrescribirá *engadir* y *baleirar*, chamando por debaixo aos métodos correspondentes.

É un pouco máis de traballo do esperado, pero así é moito mais sinxelo xestionar a nosa aplicación, xa que os nosos métodos adaptáranse e non así o noso código.

O valor engadido de usar este patrón esta, en que nun so punto tomo unha decisión que se estenderá por toda a nosa aplicación.

{lang=js}
~~~~~~~
var eventos = {
	agregar: null,
	quitar: null,
	manejador: function(evento) {
        console.group("Manexador de Eventos");
        console.log("-----------------------------");
        console.log("Type: " + evento.type); // Tipo
        console.log("Bubbles: " + evento.bubbles); // sube por el DOM
        console.log("Cancelable: " + evento.cancelable);
        console.log("CurrentTarget: ", evento.currentTarget);
        console.log("DefaultPrevented: " + evento.defaultPrevented);
        console.log("EventPhase: " + evento.eventPhase);
        console.log("Target: ", evento.target);
        console.log("TimeStamp: " + evento.timeStamp);
        console.log("IsTrusted: " + evento.isTrusted); // true - Usuario
        console.log("=============================");
		console.groupEnd();
	}
}

// Init-time branching (Patrón)
if (typeof window.addEventListener === 'function') {
    eventos.engadir = function(el, type, fn) {
    	el.addEventListener(type, fn, false);
	};
	eventos.quitar = function(el, type, fn) {
	   	el.removeEventListener(type, fn, false);
	};
} else { // Soporte para <= IE8
    eventos.engadir = function(el, type, fn) {
        el.attachEvent('on' + type, fn);
    };
    eventos.quitar = function(el, type, fn) {
        el.detachEvent('on' + type, fn);
    };
}

eventos.engadir(document.body, 'click', function (e) {
	var cor = 'rgb(' + Math.floor((Math.random() * 255))+ ',';
	cor += Math.floor((Math.random() * 255)) + ',';
	cor += Math.floor((Math.random() * 255)) + ')';
	document.body.style.backgroundColor= cor;
	console.info("Nova cor:", cor);
})
~~~~~~~


#### Delegación de Eventos

Unha das técnicas máis útiles pra aforrar memoria, é utilizala *delegación de eventos*, é dicir, en vez de poñer un evento por cada un dos elementos que compón unha estrutura de datos, é preferible facelo unicamente, sobre o elemento pai común a todos eles e simplemente filtrar cal dos fillos foi disparado.


**Modo Clásico (sen delegación)**

{lang=html}
~~~~~~~
<ul id="meuNav">
	<li><a href="#nos">¿Quen Somos?</a></li>
	<li><a href="#obxectivos">Os obxectivos</a></li>
	<li><a href="#equipo">Noso Equipo</a></li>
	<li><a href="#detalles">Máis detalles</a></li>
	<li><a href="#contacta">Contactanos</a></li>
</ul>
~~~~~~~


{lang=js}
~~~~~~~
var meuNav = document.getElementById("meuNav");
var meuNavLinks = meuNav.getElementsByTagName("a");

for (var i = 0; i < meuNavLinks.length; i++) {
    meuNavLinks[i].onclick = function(){
	    console.info(this.innerHTML);
	}
};
~~~~~~~





**Modo Delegando**

{lang=js}
~~~~~~~
var meuNav = document.getElementById("meuNav");
meuNav.onclick = function(evento){

var evento = evento || window.event;
var elemento = evento.target || evento.srcElement;
    console.info(elemento.innerHTML);
};
~~~~~~~



#### Creación de Eventos Personalizados

Outra estratexia máis avanzada, é facer o noso código máis modular e interconectado por eventos, anque isto é máis típico de Node.js. No lado do cliente tamén podemos facer uso de isto.

I> Como verás incluso podemos disparar eventos, o que amplía moito sas posibilidades pra
I> xogar con páxinas web existentes dende a consola... ***[¡Eu non digo nada...!](https://gist
I> .github.com/UlisesGascon/57ed4ed61fbc987b0e3265568a27f6c4)***

{lang=js}
~~~~~~~
var evento = new Event('meuEventoInventado');

document.body.addEventListener('meuEventoInventado', function (e) {
	console.info(e); // {isTrusted: false}
});

document.body.dispatchEvent(evento);
~~~~~~~


{pagebreak}


## Propagación (Capturing e Bubbling)

Un dos puntos de fricción máis altos a hora de traballar con eventos, é entender como funciona a propagación que JavaScript realiza.

![Imaxe obtida de W3C](images/eventflow.png)

A mellor maneira de entendelo é cun *[exemplo](http://jsfiddle.net/x72ez79t/)*.

Se executas o evento verás que existe un pequeno conflito de intereses no HTML.

{lang=html}
~~~~~~~
<div id="parent">
    <div id="children">
        Click
    </div>
</div>
~~~~~~~

Tanto *parent* como *children* teñen eventos subscritos. O problema básico, que nos atopamos é que *children* está envolto por *parent*, o que fai que pinchemos, onde pinchemos sempre dispáranse ambos.

Isto debese a propagación, que funciona en tres fases:


Capturing

: Recorre todo o documento dende *document* ata o elemento en si.


Target

: É cando chegase a elementos en cuestión.


Bubbling

: Realiza o recorrido de volta ata arriba dende o elemento en si.


Podemos interromper este proceso de propagación se facemos uso de *[stopPropagation()](https://developer.mozilla.org/es/docs/Web/API/Event/stopPropagation)*.

Como viche, o exemplo en si que utilizamos aquí, forza un pouco a situación, xa que existe moito código duplicado e xestiona os eventos dunha maneira incorrecta.

Outro método interesante, que non debemos perder de vista é *[.preventDefault](https://developer.mozilla.org/es/docs/Web/API/Event/preventDefault)*. Evita o comportamento por defecto, por exemplo se queremos que un link non actúe como tal.

Ao contrario do que poda parecer agora mesmo, a propagación é un dos mellores aliados a a hora de xestionar os nosos eventos, como vimos anteriormente coa *delegación de eventos*.
