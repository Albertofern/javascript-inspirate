# Capítulo 10 - Funcións

{:: encoding="utf-8" /}
{footnotes-off}

As funcións de JavaScript son a alma desta linguaxe, por iso considéranse *[cidadáns de primeira clase (first-class citizen)](https://en.wikipedia.org/wiki/First-class_citizen)*, ademais de *[entidades de orde superior](https://es.wikipedia.org/wiki/Funci%C3%B3n_de_orden_superior)*.

En JavaScript, as funcións teñen *"super poderes"*. Estes son algúns dos máis importantes:

- Ser pasadas como parámetros *[(callbacks)](https://es.wikipedia.org/wiki/Callback_(inform%C3%A1tica))*.
- Ser parte dos obxectos como métodos.
- Ser asignadas a unha variable (función anónima).
- Ser retornadas por outra función.

Unha das claves pra entender a importancia das funcións, aínda cando estamos dando os nosos  primeiros pasos en JavaScript é a reusabilidade. Podemos crear partes de código que facilmente poderemos reutilizalo ao longo dunha aplicación ou incluso ao longo de moitos programas e aplicacións... chegando incluso a crear as nosas propias librerías.

Pero pra dominar a reusabilidade e respectar con profundidade o principio de programación *[DRY (Don't Repeat Yourself)](https://es.wikipedia.org/wiki/No_te_repitas)*, deberemos en calquera caso ser capaces de manexar os parámetros e o retorno das funcións, algo do que falaremos moito neste capítulo.

As funcións, especialmente como *[parámetro (callback)](https://es.wikipedia.org/wiki/Callback_(inform%C3%A1tica))*, tamén será a nosa porta de entrada ao marabilloso, caótico e paradigmático *[mundo de la asincronía](https://carlosazaustre.es/blog/manejando-la-asincronia-en-javascript/)*.

## Manexo

- **Declarar funcións**

	Como sentenza:

    {lang=js}
    ~~~~~~~
    function miñaFuncion (){
    	console.log("Ola!")
    }
    ~~~~~~~



    Como valor dunha variable:

    {lang=js}
    ~~~~~~~
    var miñaFuncion = function(){
    	console.log("Ola!")
    }
    ~~~~~~~

	{pagebreak}

    Como método dun obxecto:

    {lang=js}
    ~~~~~~~
    var meuObjeto = {
    	propiedade: "Son unha propiedade",
    	metodo: function(){
    		console.log("Ola!")
    	}
    }
    ~~~~~~~

- **Executar funcións**

	Anque poda parecer algo estraño, dende o principio, xa estábamos executando funcións.

    {lang=js}
    ~~~~~~~
    // Recordas isNaN?
    console.log("Recordas isNaN?", isNaN(NaN))
    ~~~~~~~

	Agora executamos as nosas propias funcións e métodos.

    {lang=js}
    ~~~~~~~
    var miñaFuncion = function(){
    	console.log("Ola!");
    }

   	function outraFunción() {
   		console.log("Ola de novo!");
   	}

   	var obj = {
   		metodo: function () {
   			console.log("Ola... agora como método!");
   		}
   	}

    miñaFuncion();
    outraFunción();
    obj.metodo();
    ~~~~~~~


## *[Argumentos e parámetros](https://es.wikipedia.org/wiki/Argumento_(inform%C3%A1tica))*

Cando queremos facer funcións cun nivel de abstracción realmente alto, temos que recurrir ao illamento. De tal forma que a nosa función no dependa de certas variables ou datos externos a ela.

Cando definimos (creamos) unha función, podemos incluír certos parámetros entre os parénteses que actuarán como referencias. Funcionarán internamente igual que variables, de tal forma que a hora de executala función... poderemos pasarlle certos argumentos e así ter funcións cun maior nivel de abstracción.

{pagebreak}

### Uso Normal

{lang=js}
~~~~~~~
// Declarando Parámetros
function sumar (p1, p2){
	console.log("suma:", p1 + p2)
}

// Pasando Argumentos
sumar(2, 3);
~~~~~~~

O exceso de argumentos non é un problema.

{lang=js}
~~~~~~~
// Declarando Parámetros
function sumar (p1, p2){
	console.log("suma:", p1 + p2)
}

// Pasando Argumentos
sumar(2, 3, "máis datos...", 45, true);
~~~~~~~

A falta de argumento crea un valor indefinido.

{lang=js}
~~~~~~~
function testeando (p1, p2){
	console.log("p1:", p1);
	console.log("p2:", p2)
}

// Pasando Argumentos
testeando(2);
~~~~~~~


### Parámetros opcionais

Poderemos simplificar enormemente a execución de las funciones si, definimos certos valores por defecto pra aqueles parámetros que consideremos opcionais.

Este traballo adicional pola nosa parte, verase recompensado posteriormente en tarefas de soporte e documentación que non teremos que realizar.

Traballar con valores por defecto axudaranos moito pra construír librerías e un código modular eficiente.

Basicamente existen dúas maneiras de facer isto.

{pagebreak}

- **Utilizando o operador _||_**

	{lang=js}
	~~~~~~~
	function userID(nome, numero) {
	  numero = numero || "000000E";
	  console.log("ID:", nome + "-" + numero)
	}

	userID("Ulises", 31); // Ulises-31
	userID("Oscar");      // Oscar-000000E
	userID("Pepe", 0)     // Pepe-000000E
	~~~~~~~

	Anque este operador fai un bo traballo equivocase co 0 -entre outros- por iso non é recomendable utilizalo, especialmente cando encargase de xestionar o parámetro por defecto de valores numéricos.


- **Utilizando un _if_**

	Podemos facer unha validación por tipo, o que descartará certos falsos positivos como no caso do 0.

	{lang=js}
	~~~~~~~
	function sumar(a, b) {
	  if(typeof b === 'undefined'){
	  	b = 0;
	  }

	  return a+b;
	}

	sumar(2);    // 2
	sumar(2, 8); // 10
	~~~~~~~

	Cun operador ternario faise máis compacto pero menos lexible:

	{lang=js}
	~~~~~~~
	function sumar(a, b) {
	  b = typeof b !== 'undefined' ?  b : 0;
	  return a+b;
	}

	sumar(2);    // 2
	sumar(2, 8); // 10
	~~~~~~~

{pagebreak}


### A orde é a chave

A orde dos parámetros é moi importante, xa que a súa posición pode alterar enormemente a usabilidade a hora da execución, por iso a orde sempre será:

- Parámetros fixos (primeiro).
- Parámetros opcionais (despois).


### Obxectos como argumento

Considerase unha boa práctica, pasar un único obxecto como parámetro se estamos manexando máis de tres parámetros fixos.

Desta forma ademais de agrupar todo facilmente, tamén podemos cambiala orde de entrada de datos.

É importante recordar que debemos documentar moi ben o que esperamos, que conteña o obxecto, do contrario os nosos métodos e funcións poden ser un inferno pra calquera outro desenvolvente e incluso pra nos mesmos pasado un tempo.

{lang=js}
~~~~~~~
contactos = [];

function crearContacto (nome, usuarioTwitter, referencias, notas, fotoUrl){
	contactos.push({
		"nome": nome,
		"@": "@" + twitter
	})
}

crearContacto("Oscar", "inventado", "amigos...", "etc...", "más cosas...");
~~~~~~~

**¡Refactorizemos!**

{lang=js}
~~~~~~~
contactos = [];

function crearContacto (datos){
	contactos.push({
		"nome": datos.nome,
		"@": "@" + datos.twitter
	})
}

// Podo pasalos atributos na orde que queira
crearContacto({twitter: "inventado", nome: "Pepe", fotoUrl: "http..."});
~~~~~~~

{pagebreak}

### Avanzado: Obxecto *arguments*

O Obxecto Arguments non é un array, solo é similar.

{lang=js}
~~~~~~~
function probaArgumentos () {
	console.log(arguments);
	console.info(arguments[0]);
	console.info(arguments[1]);
}

probaArgumentos (1, "vale", true);
~~~~~~~

T> Conversión array require de certos coñecementos avanzados no uso de
T> *[protoype](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript)* y
T> *[this](https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Operadores/this)*. Déixovos
T> unha función que vos axudará a realizar esta conversión dunha forma fácil.
T>
T> {lang=js}
T> ~~~~~~~
T> function conversorArgumentos(arguments) {
T>     var argumentos = Array.prototype.slice.call(arguments);
T>     return argumentos.sort();
T> }
T> ~~~~~~~


## Retorno

Outro dos puntos fortes a hora de plantexar estruturas de código modulares e reutilizables, é ter en conta o retorno. 

O retorno permítenos devolver un valor ao terminar de executarse a función. Este valor pode ser calquera tipo de dato dos moitos que tenemos en JavaScript. Por suposto, tamén funcións e obxectos.

Como utilizar funcións que retornen valores en función de certas operacións realizadas.

{lang=js}
~~~~~~~
	function validarPar(numero){
		var ePar = numero % 2 !== 1;
		var mensaxe;

		if (ePar) {
			mensaxe = "Bravo! é un número par!";
		} else {
			mensaxe = "ERRO! Non é un número par.... ¬¬\"";
		}
		return mensaxe;
	};

	console.log("O 5 é un número par?", validarPar(5));
	console.log("O 2 é un número par?", validarPar(2));
~~~~~~~

Unha suma de cadrados no retorno. As operacións tamén poden ser realizadas no retorno da función.

{lang=js}
~~~~~~~
function sumaCadrados (a, b) {
	return (a*a) + (b*b);
};

var resultado = sumaCadrados(2, 3);
console.log("2x2 + 3x3 =", resultado)
~~~~~~~

## Anidación

Dentro dunha función, podemos crear novas funcións ao igual que variables de todo tipo. Este é un recurso a ter en conta, pero non debemos abusar da anidación... xa que, o código pode volverse moi difícil de ler e depurar.

{lang=js}
~~~~~~~
function saudar(quen){
        function alertaSaudo(){
                console.log("Ola " +  quen);
        }
        return alertaSaudo;
}

var sauda = saudar("Amigo/a");
sauda();
~~~~~~~

Tamén podemos usar parámetros, ao igual que unha función normal.

{lang=js}
~~~~~~~
function saudar(quien){
        function alertaSaudo(){
                console.log("Ola " +  quen);
        }
        return alertaSaudo;
}

saudar("Amigo/a")();
~~~~~~~

## Ámbito (Scope)

Por defecto en JavaScript existen dous tipos de ámbitos, local e global. Dominar os ámbitos faranos chegar a ser grandes artesáns, pero non é unha tarefa sinxela.

En principio aquelas variables que se declararon fora da función, son de ámbito global, e as variables que se declaran no interior serán consideradas de ámbito local.

Desde calquera función sempre poderemos acceder a tódalas variables que se declararan no ámbito global, pero dende o exterior dunha función non poderemos acceder ao seu ámbito local. Pra poder solventar esta limitación utilízanse os retornos que vimos anteriormente e algúns recursos adicionais que veremos máis adiante.

{lang=js}
~~~~~~~
var ambitoGlobal = "Son unha variable Global!";

function miñaFuncion () {
	var ambitoLocal = "Son unha variable Local!";
	console.log("Dende local podo ver ambitoLocal?", ambitoLocal);
	console.log("Dende local podo ver ambitoGlobal?", ambitoGlobal);
}

console.log("Dende local podo ver ambitoLocal?", ambitoLocal);
//Uncaught ReferenceError: ambitoLocal is not defined(…)

console.log("Dende local podo ver ambitoGlobal?", ambitoGlobal);
~~~~~~~

Este xogo de ámbito local e global, pode estenderse no entorno compartido e illado das funcións anidadas.

W> **Duplicando Variables**
W>
W> Unha mala práctica a hora de planificar nomes das variables na nosa aplicación pode
W> levarnos a situación na que teñamos variables creadas (declaradas) no ámbito global
W> e no local cos mesmos nomes.
W>
W> Isto pode ser evitado dende a planificación nunha fase prematura ou posterior con algún
W> *linter* como *[JSHint](http://jshint.com/)* o *[ESLint](http://eslint.org/)*.



## Funciones Anónimas

En JavaScript podemos crear tantas funciones como queiramos, sen embargo entre os requisitos de creación non esta incluír un nome necesariamente.

### Funcións que retornan funcións

Cando unha función retorna una nova función, esta nova función loxicamente será anónima.

{lang=js}
~~~~~~~
function saudo(quen){
    return function(){
        console.log("Ola " + quen);
    }
}

var sauda = saudo("Amigo/a");
sauda();
~~~~~~~

Podemos executar ambas funcións, sen asignar unha variable necesariamente.

{lang=js}
~~~~~~~
function saudo(quen){
    return function(){
        console.log("Ola " + quen);
    }
}

saudo("Amigo/a")();
~~~~~~~

### Funcións anónimas autoexecutadas

I> É un dos patróns máis clásicos é utilizados en JavaScript, pra encapsular o noso 
I> código e prever que poda ser alterado dende o exterior.

Esta técnica da moito xogo, se temos en conta que podemos usalo retorno.

Ao illar o noso código tanto do exterior, podemos pensar que o noso programa queda lonxe de ser capaz de interactuar co usuario, pero isto é incorrecto, xa que en JavaScript poderemos recurrir a *[programación dirixida por eventos](https://es.wikipedia.org/wiki/Programaci%C3%B3n_dirigida_por_eventos)*. Falaremos nos próximos capítulos sobre isto.

{lang=js}
~~~~~~~
(function() {
	console.log("Ola Amigo/a")
})();
~~~~~~~

Resulta máis sinxelo entender esta estrutura se entendemos o xogo dos parénteses.

Declaramos unha función:

{lang=js}
~~~~~~~
(//código)()
~~~~~~~

O contido no primeiro paréntese conten o código encapsulado, ao igual que facíamos coas operacións matemáticas en capítulos anteriores.

O segundo paréntese é o encargado de executar o bloque de código anterior, así é como logramos que a función sexa inmediatamente executada dentro dun ámbito ao que non poderemos acceder.


Como podemos ver a estrutura básica sería algo así:

{lang=js}
~~~~~~~
(function(){})();
~~~~~~~

Anque existen bastantes variantes e debates:

{lang=js}
~~~~~~~
(function(){}());
!function(){}();
+function(){}();
!1%-+~function(){}();
//...
~~~~~~~

Ao igual que o resto de funcións podemos facer uso dos parámetros.

{lang=js}
~~~~~~~
( function(quen){
   console.log("Ola " + quen);
})("Amigo/a");
~~~~~~~

I> **[Obxecto Window](https://developer.mozilla.org/es/docs/Web/API/Window) como parámetro**
I>
I> Anque por temas de rendemento -o máis habitual- é pasar como argumento o *[obxecto
I> window](https://developer.mozilla.org/es/docs/Web/API/Window)*, así dispoñemos dunha copia
I> dentro do propio ámbito da función.
I>
I> {lang=js}
I> ~~~~~~~
I> (function(window){
I>   // código
I> })(window);
I> ~~~~~~~

## Recursión

Outra maneira máis *[funcional](https://es.wikipedia.org/wiki/Programaci%C3%B3n_funcional)* e divertida de facer bucles é utilizando a recursión. Básicamente unha función é capaz de chamarse a si mesma durante a súa execución, o que resulta ser unha funcionalidade moi atractiva pra certas operacións.

W> Por outro lado, anque é una práctica moi habitual entre os desenvolventes -que defenden- 
W> a *[programación funcional](https://es.wikipedia.org/wiki/Programaci%C3%B3n_funcional)* en
W> JavaScript, pode ser complicado prever o risco de caer en bucles infinitos.


{pagebreak}


Un clásico onde podemos aplicar recursividade é o cálculo do *[factorial](https://www.wikiwand.com/es/Factorial)*.

{lang=js}
~~~~~~~
function factorial(n){
	if(n <= 1){
    	return 1
  	} else {
    	return n * factorial(n-1)
	}
}

factorial(0); // n! = 1
factorial(1); // n! = 1
factorial(2); // n! = 2
factorial(3); // n! = 6 (3*2*1)
factorial(4); // n! = 24 (4*3*2*1)
factorial(5); // n! = 120 (5*4*3*2*1)
factorial(6); // n! = 720 (...)
~~~~~~~


## *[Callbacks](https://developer.mozilla.org/en-US/docs/Mozilla/js-ctypes/Using_js-ctypes/Declaring_and_Using_Callbacks)*

I> **A primeira curiosidade sobre os callbacks:**
I>
I> É unha técnica de programación é non unha facilidade da linguaxe, por iso *[callback](https://developer.mozilla.org/en-US/docs/Mozilla/js-ctypes/Using_js-ctypes/Declaring_and_Using_Callbacks)* non é unha
I> palabra reservada en JavaScript, e podes usala no teu código, si che resulta máis lexible.

{icon=quote-left}
G> ***[Callbacks en Wikiwand](https://www.wikiwand.com/es/Callback_(inform%C3%A1tica)):***
G>
G> *"Na programación de computadoras, unha devolución de chamada ou
G> retrochamada (en inglés: callback) é una función "A" que se usa como
G> argumento de outra función "B". Cando se chama a "B", esta executa "A".
G> Pra conseguilo, usualmente o que pasa a "B" é o punteiro a "A"."*


Isto quere dicir, **que cando certa función termina de realizar todo o que ten que facer, executará unha función que foi pasada como argumento**.

Nun principio, este concepto parece complicado, e sen dubida é, pero este sistema e o primeiro paso pra manexar a asincronía. Isto sucederá cando o noso código deixa de executarse de maneira estruturada liña a liña, por exemplo coas *[peticións AJAX](https://developer.mozilla.org/es/docs/AJAX/Primeros_Pasos)*, o que veremos en próximos capítulos.


### Comparando por contexto

Cando temos un código síncrono, facilmente podemos obviar o uso de callbacks, e chegar ao mesmo resultado, xa que o noso código segue un orden lóxico.

{pagebreak}

**Sen Callbacks:**

{lang=js}
~~~~~~~
function primeiroPaso() {
	console.log("Este é o primeiro paso");
};

function segundoPaso() {
	console.log("Este é o segundo paso");
};

primeiroPaso();
segundoPaso();
~~~~~~~

**Con Callbacks:**

{lang=js}
~~~~~~~
function primeiroPaso(callback) {
	console.log("Este é o primeiro paso");
	callback();
};

function segundoPaso() {
	console.log("Este é o segundo paso");
};

primeiroPaso(segundoPaso);
~~~~~~~

Cando o noso código execútese de forma asíncrona, a única forma de conservar o fluxo en orde, será utilizando entre outras cousas *[Callbacks](https://developer.mozilla.org/en-US/docs/Mozilla/js-ctypes/Using_js-ctypes/Declaring_and_Using_Callbacks)* o *[Promesas](https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Promesa)*, como vemos a continuación.

I> Se desenvolviche algunha vez con JQuery, notache que ten unhas características
I> lixeiramente diferentes ao JavaScript ao que estamos acostumados.
I>
I> {lang=js}
I> ~~~~~~~
I> $('#elemento').fadeIn('slow', function() {
I>   	// código do callback
I> });
I> ~~~~~~~
I>
I> Como podes ver... en moitos métodos, pasamos como argumento unha función que 
I> declaramos en liña.
I> Basicamente... **¡xa estábamos usando callbacks!** pero non eramos conscientes.


{pagebreak}


Vexamos un exemplo, un pouco condensado. Axudareivos comentando o código:

{lang=js}
~~~~~~~
/*
	Declaramos unha función que espera dous parámetros
	- parámetro
	- callback
*/
var queroCallback = function(p1, callback){
    // Consideramos o callback como algo opcional.
    if ((callback){
    	// Validamos si é unha función o non.
    	if (typeof callback === 'function')){
    		/*
    		  Se é unha función executámolo e
    		  pasamos como argumento "p1"
    		*/
        	callback(p1);
	    } else {
	    	/*
	    	  Se non se trata dunha función...
	    	  simplemente mostramos ambos datos.
	    	 */
	        console.log(p1, callback);
		}
    }
}

queroCallback('a', 'b');

queroCallback('a', function(val){
    console.log(val);
});
~~~~~~~


## Asincronía

I> **A natureza da Asincronía**
I>
I> Ata agora todo o código que vimos executouse dunha maneira lóxica, 
I> previsible é secuencial.
I> Cada liña de código foi executada despois da anterior, tardara o que tardara.
I> Este estilo de programación é ineficiente e bloquéante, o que no mundo da 
I> web é intolerable.
I>
I> A asincronía é unha característica propia de certos métodos que permiten a súa 
I> execución nun segundo plano.
I> De tal forma que resulta imposible saber cando terminarán e ademais antes de rematar a súa execución executase a seguinte liña de código.


Cando en JavaScript falase de asincronía, o que realmente esta ocorrendo é que deixamos de executar partes do noso script de maneira secuencial. Isto crea un efecto curioso que ten como consecuencia, un script moi escalable e rápido, xa que o sistema non espera a que algo termine pra seguir executando o resto do script.

I> A mala noticia, é que recaerá no lector todo o peso de controlar estes cabalos 
I> desbocados. 
I> A asincronía é tan potente, que non existe outra forma de traballar sobre Node.js. Por
I> iso Node.js está concibido -dun principio a un fin- como un sistema asíncrono.

Existen moitas formas de manexar la asincronía.

- Paso de continuadores (Callbacks).
- Eventos.
- Promesas (ECMA6 e librerías...).
- Xeradores (ECMA6, Closures, etc...).

Veremos neste este capítulo -exclusivamente- a xestión de asincronía por medio de callbacks.

No próximo capítulo falaremos de *[programación dirixida por eventos](https://es.wikipedia.org/wiki/Programaci%C3%B3n_dirigida_por_eventos)* é como xestionar con iso a asincronía.


Pra facer un pouco máis fluído esta explicación, utilizaremos *[setTimeout](https://developer.mozilla.org/es/docs/Web/API/WindowTimers/setTimeout)* que por defecto é unha función asíncrona.

Vexamos como funciona o código sen xestionar a asincronía:

{lang=js}
~~~~~~~
function traigoDatos (){
    // Asincrona
    setTimeout (function(){
        console.log ("Isto son os meus datos");
    },2000)
}

function pintoDatos(){
    // Non asincrona
    console.log("xa teño os datos");
}
traigoDatos();
pintoDatos();
~~~~~~~

Como podes ver... as mensaxes non saen na orde correcta. Recorda que, pra pintar datos, o paso previo -sempre- é ter os datos dispoñibles.

Agora vamos a intentar resolver este problema dunha maneira sinxela. Se introducimos un callback na función asíncrona, seremos capaces de resolver o problema... anque tarde 3 segundos ou 5 minutos.

{lang=js}
~~~~~~~
function traigoDatos (callback){
    // Asincrona
    setTimeout (function(){
        console.log ("Isto son os meus datos");
        // Chamamos a Callback cando chegou o fin de traigoDatos.
        callback();
    },2000)
}

function pintoDatos(){
    // Non asincrona
    console.log("Xa teño os datos");
}

traigoDatos(pintoDatos);
~~~~~~~

Ao executalo podemos ver que o problema da asincronía foi resolto.

Normalmente, a hora de facer peticións asíncronas, solemos *pedir/enviar* información ao servidor... é facemos isto a través de peticións AJAX (tamén asíncronas). Cando realizamos ese tipo de chamadas, queremos pasarlle ao callback os datos que chegaron do servidor.

¡Vexamos como facelo!


{lang=js}
~~~~~~~
function traigoDatos (callback){
    // Asíncrona
    setTimeout (function(){
        // moitas cousas pasan...
        var resultado = "Isto son os meus datos";
        // Chamamos a Callback é pasamos o resultado
        callback(resultado);
    },2000)
}

function pintoDatos(data){
    // Non asíncrona
    console.log("xa teño os datos:");
    console.log(data);
}

traigoDatos(pintoDatos);
~~~~~~~


{pagebreak}


### Sobrevivir ao *[Callback Hell](http://callbackhell.com/)*

*[Callback Hell](http://callbackhell.com/)* é unha situación que sóese producir cando os desenvolventes non dominan o manexo da asincronía, nin o uso dos callbacks. Tamén prodúcese, cando non respectan conceptos básicos de modularización é prevención de anidación desmedida.


Algunhas solucións a este problema:

- Non anidar en exceso... ¿Oiche falar da *[complexidade ciclomática](https://es.wikipedia.org/wiki/Complejidad_ciclom%C3%A1tica)*?.
- Calquera anidación de funcións a máis de dous o tres niveis esta pedindo a gritos unha refactorización.
- Non tódalas funcións do teu código teñen que anónimas...
- Modularizar e refactorizar son dos teus mellores amigos en JavaScript.
- Xestiona os erros en cada función é non ao final da pila.

Si aínda así veste totalmente incapaz de prever este erro, sempre podes recorrer a *[Xeradores](https://ponyfoo.com/articles/es6-generators-in-depth)*, *[Promesas](https://ponyfoo.com/articles/es6-promises-in-depth)*, *[Funciones Async](https://ponyfoo.com/articles/understanding-javascript-async-await)*... ou librerías como *[Async](https://github.com/caolan/async)*, *[Q](https://github.com/kriskowal/q)*, etc...

## Documentar

Se recordamos o terceiro capítulo, dixemos que *[JSDoc](http://usejsdoc.org/index.html)* resultaríanos moi útil nun futuro pra entender é documentar especialmente as nosas funcións. Vexamos de novo aquel exemplo, esta vez cunha mirada máis crítica.


{lang=js}
~~~~~~~
/**
 * Retornamos detalles do libro.
 * @param {string} title - Título do libro.
 * @param {string} author - Autor do libro.
 * @returns {object} title, author, picture (referencia local), code
 */
function Book(title, author) {
	return {
		title: title,
		author: author,
		picture: "../images/"+author+"/"+title+".jpg",
		code: 010203 + author + "/" + title
	}
}
~~~~~~~

{icon=bell}
G> #### ¡Volver atrás!:
G>
G> Agora pode ser un bo momento pra volver a capítulos anteriores, 
G> onde foi necesario facer uso das funcións pra xestionar certos métodos complexos en arrays é obxectos.
