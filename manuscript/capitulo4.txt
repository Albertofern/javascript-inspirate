-# Parte II - Mecánica da linguaxe

# Capítulo 4 - Comparadores

{:: encoding="utf-8" /}
{footnotes-off}


## *[Operadores de Comparación](https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Operadores/Comparison_Operators)*

Moitos dos comparadores, maior que, menor que, igual que, etc... xa os coñecemos. Pero en JavaScript temos un comparador adicional, que permítenos comparar entre dous elementos, non so polo seu valor, tamén pola súa tipoloxía.


{lang=js}
~~~~~~~
var maiorQue = 100 > 10;
var menorQue = 10 < 100;
var maiorIgual = 100 >= 10;
var menorIgual = 10 <= 100;
var igual = 10 == 10;
var igualTotalmente = 10 === 10; // Ollo! Usamos tamén ===
var nonIgual = 100 != 10;
~~~~~~~

Como regra xeral, será imperativo utilizalo sempre que comparemos entre valores o *===*, xa que debemos asegurarnos que non nos deán "gato por lebre", confirmando que son iguais ámbolos datos en valor e tipo de dato.

Vexamos o seguinte exemplo:

{lang=js}
~~~~~~~
var igual = 10 == 10; // true
var igualCadea = 10 == "10"; //true
var igualTotalmente = 10 === 10; // true
var igualTotalmenteCadea = 10 === "10"; //false

var nonIgual = 100 != 10; // true
var nonIgualCadea = 100 != "100"; // false
var nonIgualTotalmente = 100 !== 10; // true
var nonIgualTotalmenteCadea = 100 !== "100"; // true
~~~~~~~

## *[Operadores Lógicos](https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Operadores/Operadores_l%C3%B3gicos)*

Podemos concatenar validacións e así avaliar expresións máis complexas.

En JavaScript dispoñemos de *&&* _(todo debe resolverse como verdadeiro)_ e *||* _(Ao menos un dos elementos debe ser verdadeiro)_

{pagebreak}

- **AND(&&)**

    {lang=js}
    ~~~~~~~
    console.log(true && true);      // true
    console.log(true && false);     // false
    console.log(false && false);    // false
    console.log(false && true);     // false
    ~~~~~~~

- **OR(||)**

    {lang=js}
    ~~~~~~~
    console.log(true || true);      // true
    console.log(true || false);     // true
    console.log(false || false);    // false
    console.log(false || true);     // true
    ~~~~~~~

Podemos tamén utilizalo aprendido ata agora con operacións matemáticas:

{lang=js}
~~~~~~~
var ex1 = true && true;         // true
var ex2 = (2 == 2) && (3 >= 6); // false
var ex3 = (2>3) || (17 <= 40);  // true
var ex4 = false || false;       // false
~~~~~~~

## Todo pode ser booleano

En JavaScript todo pode ser comparado en términos booleanos, especialmente se facemos uso da función *[Boolean()](https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Boolean)*.

En xeral podemos saber como responderá JavaScript, se temos en conta o *"valor real"* da expresión que desexamos validar.

Por exemplo, una cadea de texto baleira *("")* non aportará valor real, polo que será *false*.

Importante remarcar que o *0* y *-0* son false

- **Valor "real" é _true_:**

    {lang=js}
    ~~~~~~~
    console.log("valor boleano de \"JS!\":", Boolean("JS!\"));
    console.log("valor boleano de 1235:", Boolean(1235));
    console.log("valor boleano de -1235:", Boolean(-1235));
    console.log("valor boleano de un obxecto:", Boolean({saúdo: "ola"}));
    console.log("valor boleano de un array:", Boolean(["platano", -1, false]));
    console.log("valor boleano de un array:", Boolean(function(){}));
    ~~~~~~~

{pagebreak}

- **Sen valor "real" é _false_:**

    {lang=js}
    ~~~~~~~
    console.log("valor boleano de \"\":", Boolean(""));
    console.log("valor boleano de 0:", Boolean(0));
    console.log("valor boleano de -0:", Boolean(-0));
    console.log("valor boleano de null:", Boolean(null));
    console.log("valor boleano de undefined:", Boolean(undefined));
    console.log("valor boleano de NaN:", Boolean(NaN));
    ~~~~~~~

## Asignación por igualdade

Unha maneira áxil e dinámica de asignar valor as variables, é facendo uso da asignación por igual. Basicamente almacenamos o resultado booleano dunha comparación nunha variable que poderemos utilizar máis adiante.

{lang=js}
~~~~~~~
var administrador = 'Eu mesmo';
var eAdministrador = (administrador === 'Eu mesmo');
console.log(eAdministrador); // true
~~~~~~~

## *[If](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/if...else)*

Como xa vimos en pseudocódigo, unha das estruturas máis útiles a hora de xestionar o fluxo da nosa aplicación é o uso de condicionais.

*If* permítenos avaliar unha condición e actuar en consecuencia.

As instrucións que se atopan entre corchetes, execútanse so cando a condición cúmprese.


I> #### Xestiona a complexidade
I>
I> Dentro dunha estrutura condicional podemos meter máis estruturas condicionais, ademais de
I> outras estruturas típicas da linguaxe... isto coñecese coma *[anidación](https://es.wikipedia.
I> org/wiki/Anidamiento_(inform%C3%A1tica))*.
I>
I> Cando a anidación é desmesurada e pouco óptima sole elevarse moito a [complexidade ciclomática
I> ](https://es.wikipedia.org/wiki/Complejidad_ciclom%C3%A1tica) do noso código. Disto
I> falaremos nos próximos capítulos.

{lang=js}
~~~~~~~
if(1 === 1){
	console.log("1 é igual a 1 e por iso executome")
}

if(1 === "1"){
	console.log("Non son do mesmo tipo e por iso... este texto xamais será mostrado na consola.")
}
~~~~~~~

## *[If... else](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/if...else)*

En certas ocasións, necesitaremos que o noso script elixa entre dous camiños en función de se unha premisa é *verdadeira* ou *falsa*, por iso JavaScript permítenos utilizar *else*.

O programa só pode executar unha das dúas opcións, polo tanto unha parte do código quedará sen executarse.

{lang=js}
~~~~~~~
console.log("pase o que pase... isto executárase")
if (true) {
    console.log("true, por iso me executo");
} else {
    console.log("false, por iso me executo");
}
console.log("pase o que pase... isto executárase tamén")
~~~~~~~


## *[Else if...](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/if...else)*

Cando necesitemos verificar diversas opcións o máis fácil é utilizar *else if*, así evitamos ter que anidar en exceso.

É importante recordar que a primeira condición válida será a que use o interprete (navegador), e que ignorará tódalas demais.

{lang=js}
~~~~~~~
var condicion = 2;
if (condicion == 1) {
    console.log("1, por iso executome");
} else if (condicion == 2){
    console.log("2, por iso executome");
} else {
    console.log("non e 1 ou 2, por iso executome");
}
~~~~~~~


## *[Switch](https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Sentencias/switch)*

JavaScript dispón dunha opción máis pra crear estruturas condicionais.
*Switch* permite crear estruturas máis optimizadas pra cubrir un amplo abanico de casos posibles.

Por outra parte *Switch* ten varias desvantaxes notables:

* Non ten unha séntese sinxela
* É importante utilizar e comprender conceptos propios como *case*, *break* ou *default*.
* En ocasiones puede ser difícil de depurar.
* Erróneamente se piensa que *Switch* es exageradamente más rápido que *if-else*, aunque una *[simple prueba demuestra lo contrario](http://jsben.ch/#/o0UDx)*.

- **Entendendo a estrutura:**

    {lang=js}
    ~~~~~~~
	switch(expresión) {
	    case n1:
	        //Código
	        break;
	    case n2:
	        //Código
	        break;
	    default:
	        //Código
	}
    ~~~~~~~



- **Traballando con "casos únicos":**

    {lang=js}
    ~~~~~~~
	var nome = "";
	switch (nome) {
	  case "Pepe":
	    console.log("Ola Pepe");
	    break;
	  case "Luis":
	    console.log("Ola Luis");
	    break;
	  case "Antonio":
	    console.log("Ola Antonio");
	    break;
	  default:
	    console.log('Ningún dos nomes que pensamos... é '+nome);
	}
    ~~~~~~~

{pagebreak}

- **Traballando con "múltiples coincidencias":**

    {lang=js}
    ~~~~~~~
	var nome = "";
	switch (nome)
	{
	   case "Pepe":
	   case "Luis":
	   case "Antonio":
	       alert('Ola '+nome);
	       break;

	   default:
	       console.log('Ningún dos nomes que pensamos... é '+nome);
	}
    ~~~~~~~

## *[Operador Ternario](https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Operadores/Conditional_Operator)*

O *operador ternario (?:)* ofrécenos unha maneira propia de facer estruturas condicionais.

Este operador simplifica moito a sintaxe propia dos condicionais, pero desaconsellase o seu uso pra operacións ou evacuacións múltiples.

I> Se estas empezando con JavaScript, debes ter en conta, que é un operador que resulta difícil
I> de recordar ao principio. Sendo bastante común o seu uso especialmente en proxectos desenvoltos
I> con Node.js.

### Estrutura

- **Entendendo a estrutura:**

    {lang=text}
    ~~~~~~~
	condicion ? expresion1 : expresion2
    ~~~~~~~

- **Múltiples expresiones (desaconsellado):**

    {lang=text}
    ~~~~~~~
	condicion ? (
		expresion1,
		expresion2,
		otraexpresion
	) : (
		expresion1,
		expresion2,
		otraexpresion
	);
    ~~~~~~~

{pagebreak}

- **Evacuacións múltiples (moi desaconsellado):**

    {lang=text}
    ~~~~~~~
    condicion ? expresion1 : condicion2 ? expresion1 : expresion2;
    ~~~~~~~



### Exemplos

- **Sinxelo:**

    {lang=js}
    ~~~~~~~
	var eMembro = true;
	console.info("O pago son  " + (eMembro ? "20.00€" : "50.00€"));
    ~~~~~~~

- **Evaluación múltiple (moi desaconsellado):**

    {lang=js}
    ~~~~~~~
	var eMembro = true;
	var eAdulto = true;
	console.info(eMembro ? "El pago son 20.00€" : eAdulto ? "Podes enviar a solicitude cando queiras" : "Tes que esperar aínda. Sinto.");
    ~~~~~~~

- **Múltiples expresións (desaconsellado):**

    {lang=js}
    ~~~~~~~
	var mensaxe,
	eMembro = true;

	eMembro ? (
		mensaxe = "O pago son 20.00€",
		console.info(mensaxe)
	) : (
		mensaxe = "O pago son 50.00€",
		console.info(mensaxe)
	);
    ~~~~~~~
