# Capítulo 2 - Hola Mundo

{:: encoding="utf-8" /}
{footnotes-off}

I> **Salvaxe veteran**
I>
I> Neste capítulo, falaremos sobre como é a computación e que se espera dun
I> desenvolvente.
I> Se xa dominades algunha linguaxe de programación ou sinxelamente queredes comezar xa mesmo con JavaScript... pasade ao seguinte capítulo.


## Un mundo de máquinas

Seguramente, cando abras este libro terás un obxectivo sinxelo en mente, aprender JavaScript.

Pero antes de falar de JavaScript, non é mala idea empregar un pouco de tempo, en aprender algunhas cousas de interese sobre o entorno de JavaScript.

JavaScript é unha linguaxe máis de tantos que existen. Cada linguaxe ten unhas características e unhas propiedades especiais que o fan máis ou menos apto para segundo que obxectivos. Iso explica a *[existencia de tantísimas linguaxes de programación](https://es.wikipedia.org/wiki/Anexo:Lenguajes_de_programaci%C3%B3n)*, e que os desenvolventes repartámonos en función das linguaxes que utilizamos e manexamos.

As linguaxes de programación e os que utilizamos os humanos non son tan diferentes en canto ao obxectivo principal, que é comunicarnos. No caso das linguaxes dos humanos a idea principal é que podamos comunicarnos e transmitir as nosas ideas entre os individuos. Cando falase dunha linguaxe de programación, o obxectivo é lograr establecer unha comunicación fluída cunha máquina/sistema/protocolo/etc...

Ao igual que nas linguaxes humanas atopamos moitas similitudes entre si en canto a estruturación, as linguaxes de programación soen compartir unha base común en canto a estruturas e funcionalidades que toda máquina é capaz de comprender, tales como funcións, bucles, variables, condicionais, etc...

A parte máis pura da computación, *[lóxica](https://es.wikipedia.org/wiki/L%C3%B3gica)*, *[abstracción](https://es.wikipedia.org/wiki/Abstracci%C3%B3n_(inform%C3%A1tica))* e a capacidade de sintetizar unha solución pra un problema, nas *[sentencias](https://www.ecured.cu/Sentencias_(Programaci%C3%B3n))* que unha máquina poda comprender e executar.

Os ordenadores son *[máquinas multipropósito](https://es.wikipedia.org/wiki/Computadora)* que poden ser programadas. En función da súa programación poden facer máis ou menos cousas e facelas dunha forma concreta.

Por se mesmas, as máquinas non son capaces de razoar e tomar as súas propias decisións, excepto, que falemos no ámbito da intelixencia artificial, onde buscase entre outras cousas lograr máquinas e sistemas que aprendan.

Polo xeral, na computación sempre falaremos de sistemas dentro de sistemas e que foron programados... é como una pirámide que cobra todo seu sentido cando por fin temos cada un dos seus compoñentes correctamente aliñados.

JavaScript é unha linguaxe de programación de alto nivel, que se executa dentro dos navegadores, a excepción de Node.js. Isto quere dicir que o noso código necesita moito código previo pra funcionar.

Por exemplo, un sistema operativo (Linux, Windows, Mac..) que xestiona programas como o navegador (Firefox, Chrome, IE, etc...) e estes a súa vez xestionan como se representan os entornos visuais nas pantallas, os sons, etc...

Sabendo todo isto, ao final do día o noso código pode sufrir flutuacións a hora de executarse na función do entorno que esteamos usando, por sorte, o navegador xestionará de maneira automática gran parte de todo isto, pero ainda así podemos sufrir gran cantidade de variacións debido a que cada navegador "interpreta" o noso JavaScript o mellor que pode, ainda non da mesma maneira.

Un de nosos principais cometidos, será facer que o noso código sexa capaz de lograr os obxectivos que propoñémonos independentemente da plataforma onde se executara, aínda que a isto xa estaredes familiarizados co día a día desenvolvendo con HTML5 e CSS3.


## Pensar como un desenvolvente

{icon=coffee}
G> #### Lecturas recomendadas:
G>
G> - *[Don't learn to code. Learn to think by Yevgeny Brikman](http://www.ybrikman.com/writing/2014/05/19/dont-learn-to-code-learn-to-think/)*
G> - *[Linus Torvalds: A mente detrás de Linux](https://www.ted.com/talks/linus_torvalds_the_mind_behind_linux?language=es)*
G> - *[What Most Schools Don't Teach by code.org](https://www.youtube.com/watch?v=nKIu9yen5nc)*
G> - *[Computer science is for everyone by Hadi Partovi](https://www.youtube.com/watch?v=FpMNs7H24X0)*
G> - *[The early days by Steve Wozniak ](https://www.youtube.com/watch?v=PwSyjz1off4)*
G> - *[Hack your life in 48 hours by Dave Fontenot](https://www.youtube.com/watch?v=6VakF2hZFPQ)*
G> - *[You Should Learn to Program by Christian Genco](https://www.youtube.com/watch?v=xfBWk4nw440)*

Programar é un arte e o desenvolvente debería ser un artesán, aínda que tamén existen outros puntos de vista menos románticos sobre a nosa profesión.

As máquinas e os sistemas son xeniais facendo unha única cousa, seguir pasos.... A responsabilidade de todo desenvolvente en relación as máquinas é ser capaz de guialas coas instrucións máis precisas.

A diferenza dun artesán convencional, o de código, pode avaliar a beleza dun código baseándose en certos criterios. Non se trata so de que a máquina logre o obxectivo desexado, tratase tamén de non chegar a ese obxectivo cun código feo, desastroso e ineficiente.

Na programación existen criterios como consistencia, rendemento, integridade, *[complexidade ciclomática](https://es.wikipedia.org/wiki/Complejidad_ciclom%C3%A1tica)*, *[nivel de abstracción](https://es.wikipedia.org/wiki/Abstracci%C3%B3n_(inform%C3%A1tica))*, etc... Estes criterios determinan a calidade dun código.

Isto a súa vez lévanos ao análise de novos problemas relacionados coa lexibilidade e o mantemento do noso código. O balance é moi complicado e po isto un programa xamais chega a ser perfecto, recorda que ao final, o desenvolvente segue sendo humano...

I> ####Programar require aprender unha nova forma de pensar
I>
I> Moita xente omite este paso e acaba perdida nun infinito deserto de agonía e desesperación
I> cando se estancan... e vense incapaces de resolver certas situacións que xorden no día a
I> día dun desenvolvente.

Cousas como a *[metaprogramación](https://es.wikipedia.org/wiki/Metaprogramaci%C3%B3n)* e o pensamento abstracto serán dous obxectivos loables aos que debes aspirar como bo artesán do código.

Non te preocupes querido lector, porque os teus fillos non sufrirán este tormento, xa que están aprendendo programación da maneira máis áxil e divertida, centrándose no pensamento abstracto e deixando as linguaxes de programación para máis adiante... cousas como *[Scratch](https://scratch.mit.edu/)* o *[Bitbloq](http://bitbloq.bq.com/)* encárganse de axudalos con esta ardua tarefa dunha maneira amena.

Pero pra os adultos é outra historia... por iso, antes de aterrar no seguinte capítulo, deberíamos empregar un pouco máis de tempo aprendendo as bases da programación con pseudocódigo.

As máquinas procesan o mundo de maneira binaria, non existen as escalas de grises, por iso o desenvolvente debe asumir que ten que interiorizar e empatizar coa única forma de ver o mundo que teñen as máquinas. Debe aprender a pensar dunha maneira máis "binaria", isto traerá consigo beneficios máis alá da computación, como é aprender a resolver problemas complexos, dividir tarefas, etc... e así aumentará enormemente a súa creatividade. Aprenderá dos erros como nunca antes, terá novos retos cada día e cando os supere, a satisfacción será incrible...


Aprender a programar non ten idade.


## Pseudocódigo

O *[pseudocódigo](https://es.wikipedia.org/wiki/Pseudoc%C3%B3digo)* permítenos illarnos da linguaxe sobre o que finalmente desexamos programar e céntranos na base lóxica máis pura da programación, o que nos permite adentrarnos no problema en si e na súa resolución... sen ter que preocuparnos de particularidades de cada linguaxe e o seu entorno de execución.

Non imos falar de tódalas posibilidades que nos aporta o pseudocódigo, pero si falaremos dalgunhas estruturas que resultarán interesantes pra a nosa aprendizaxe orientado a JavaScript.

Anque non é necesario realizar o noso pseudocódigo nun entorno específico, existen programas como *[PseInt](http://pseint.sourceforge.net/)*, que intentan dotar dun entorno completo o noso pseudocódigo.

Por isto, os exemplos que veremos neste capítulo están baseados na sintaxe e funcionamento de *[PseInt](http://pseint.sourceforge.net/)*. Tamén inclúo a súa equiparación con JavaScript a modo de referencia.

W> **¡Non te sufoques!**
W>
W> É normal que haxa cousas que non entendamos de JavaScript nos próximos exemplos, pra iso
W> temos o resto do libro...


### Variables

Cando programamos, podemos crear variables que son pequenos espazos de memoria aos que poñemos un nome como *"nome_usuario"*, e que nos permite almacenar datos que posteriormente poderemos modificar se o desexamos.

- En Pseudocódigo:

    {lang=text}
    ~~~~~~~
    // Isto é un comentario
    nomeUsuario = "Pepe"
    nomeOutroUsuario = "Roberta"
    ~~~~~~~

- Equiparación en JavaScript:

    {lang=js}
    ~~~~~~~
    // Isto es un comentario
    var nomeUsuario = "Pepe";
    var nomeOtroUsuario = "Roberta";
    ~~~~~~~

### Interacción co usuario

Podemos pedir ao usuario que nos facilite algún tipo de dato, almacenalo nunha variable e tamén podemos mostrarlle información.

- En Pseudocódigo:

    {lang=text}
    ~~~~~~~
    // Mostrarémoslle a seguinte mensaxe
	Escribir "Ola usuario! ¿Como te chamas?"

	// Almacenamos a súa resposta nunha variable
	Ler nomeUsuario
    ~~~~~~~

- Equiparación en JavaScript:

    {lang=js}
    ~~~~~~~
    // Mostrarémoslle a seguinte mensaxe
	var mensaxe = "Ola usuario! ¿Como te chamas?";

	// Almacenamos a súa resposta nunha variable
	var nomeUsuario = prompt(mensaxe);
    ~~~~~~~

Como podemos ver... a hora de equiparar este mensaxe en JavaScript, metín certos cambios pra axilizar o *[algoritmo](https://es.wikipedia.org/wiki/Algoritmo)* e adaptalo ao contexto de JavaScript no navegador.


### Estruturas condicionais

Cando necesitamos que o sistema tome decisións, debemos plantexarlle as múltiples opcións na  estrutura condicional concreta.

Pra que la lóxica do sistema poda decidir, necesitamos reducir todo a comparacións susceptibles a devolver un *[valor booleano (verdadeiro ou falso)](https://es.wikipedia.org/wiki/Tipo_de_dato_l%C3%B3gico)*.

**Por exemplo:**

* Operacións matemáticas

    * 1+1 = 2
    * 5 é maior que 3
    * -5 é menor que cero

- Operacións lóxicas

    * A variable "nomeUsuario" é igual a "Pepe"
    * A variable "nomeUsuario" non esta baleira


A hora de representalas opcións. *[PseInt](http://pseint.sourceforge.net/)* danos dúas opcións principais. A estrutura *Si.. entón* e *Segundo*, a diferenza neste contexto está na función do número de opcións.


No caso de *Si...*

: Entón so manexamos dúas opcións cando a condición cúmprese, e cando non se cumpre.


No caso de *Segundo*

: Podemos manexar múltiples valores e co elo múltiples opcións sobre as que o sistema deberá decidir.

: Se unha condición pode cumprirse en múltiples casos, o sistema decidirase pola primeira e ignorará o resto.




**Si... Entón**

- En Pseudocódigo:

    {lang=text}
    ~~~~~~~
	Se 1 + 1 == 2 Entón
		Escribir "A suma é correcta"
	Se non
		Escribir "A suma é incorrecta"
	Fin Se
    ~~~~~~~

{pagebreak}

- Equiparación en JavaScript:

    {lang=js}
    ~~~~~~~
    if (1 + 1 === 2) {
        console.log("A suma é correcta")
    } else {
        console.log("A suma é incorrecta")
    };
    ~~~~~~~


**Segundo**

- En Pseudocódigo:

    {lang=text}
    ~~~~~~~
	Escribir "ola usuario! ¿Como te chamas?"
	Ler nomeUsuario
	Segundo nomeUsuario Facer
		"Pepe":
			Escribir "Ola Pepe! Eu coñézote"
		"Lucia":
			Escribir "Ola Lucia! Eu coñézote"
		Doutro Modo:
			Escribir "Eres novo... Benvido!"
		Fin Segundo
    ~~~~~~~


- Equiparación en JavaScript:

    {lang=js}
    ~~~~~~~
	var nomeUsuario = prompt("ola usuario! ¿Como te chamas?")

    switch(nomeUsuario) {
        case "Pepe":
            console.log("Ola Pepe! Eu coñézote");
            break;
        case "Lucia":
            console.log("Ola Lucia! Eu coñézote");
            break;
        default:
            console.log("Eres novo... Benvido!");
    }
    ~~~~~~~


### Bucles

En ocasións o noso algoritmo requirirá executar unha serie de instrucións de maneira repetitiva ata que certa circunstancia cambie. Isto en programación coñecese como bucles, basicamente temos tres tipos.

Ao existir tres tipos, xurde a dubida de saber se realmente existen diferenzas significativas entre eles.

Como é normal existen certas diferenzas no manexo das interaccións, pero tódolos bucles manteñen unha estrutura e funcionamento común que se divide en dúas partes:

Condición

: Permitinos definir cal é a condición que debe cumprirse pra que o noso programa decida se hai que *entrar/seguir* no bucle ou *ignoralo/saír*.

: O dominio desta parte do bucle aseguráranos non caer en bucles infinitos ou bucles que nunca serán executados.


Instrucións

: Nun conxunto de comandos que serán executados unha vez que o bucle validará as condicións.


#### Tipos de bucles

- **While (Mentres)**

    Esta pensado pra aqueles bucles que requiran dunha condición lóxica e non matemática pra validala iteración.


	T> Anque loxicamente poderemos mesturar entre as diversas condicións (matemáticas e lóxicas).



    - En Pseudocódigo:

        {lang=text}
        ~~~~~~~
        volta <- 0
        Mentres volta < 100 Facer
            Escribir volta
            volta = volta + 1
        Fin Mentres
        ~~~~~~~

    - Equiparación en JavaScript:

        {lang=js}
        ~~~~~~~
        var volta = 0;

        while(volta < 100){
            console.log(volta)
            volta++ // volta = volta +1
        }
        ~~~~~~~



- **For (Pra)**

    Esta deseñado especificamente pra traballar con series de números (lonxitude de cadea, elementos dun array, propiedades dun obxecto, etc...) e abastécenos dunha estrutura máis sinxela pra xestionar o fluxo.

    - En Pseudocódigo:

        {lang=text}
        ~~~~~~~
        Pra v_numerica<-v_inicial ata volta < 100 Con Paso volta = volta + 1 Facer
		    Escribir volta
	    Fin Pra
        ~~~~~~~
        
    {pagebreak}

    - Equiparación en JavaScript:

        {lang=js}
        ~~~~~~~
        for(var volta = 0; volta < 100; volta++ ){
            console.log(volta);
        }
        ~~~~~~~

- **Do... While (Repetir... Ata Que)**

    Este bucle funciona dunha maneira diferente. Altera o orden ao que estamos acostumados, xa que primeiro executará o código unha vez e logo avaliará se debe repetirse.

    - En Pseudocódigo:

        {lang=text}
        ~~~~~~~
        dato <- Falso
        Repetir
            Escribir "Polo menos unha vez..."
        Ata Que Dato == Verdadeiro
        ~~~~~~~

    - Equiparación en JavaScript:

        {lang=js}
        ~~~~~~~
        var Dato = false;

        do {
            console.log("Polo menos unha vez...");
        } while(Dato)
        ~~~~~~~

### Funcións ou subprocesos

As funcións son estruturas de código que permítennos reutilizar en gran medida o noso código, grazas a que encapsulan instrucións no seu interior.

As funcións poden realizar dúas accións principais, de maneira independente ou interrelacionadas.

Poden modificar o valor das variables que están fora da función (ámbito global) ou retornando un novo valor ao final da súa execución.

Outra das características que fan das funcións estruturas moi valiosas, é o uso de argumentos. Isto é unha especie de variable que se declara xunto a execución e que non ten ningún valor ata que non chamemos a función.

A hora de chamar a función podemos pasarlle parámetros que son valores cos que a función poderá realizar todo tipo de operacións.

Todo sistema, incluso *[PSeInt](http://pseint.sourceforge.net/)*, dispón de funcións que foron creadas pra facilitar o noso traballo, como son as funcións matemáticas que nos permiten calcular, dende valores absolutos ata logaritmos, pasando por funcións de azar pra xerar números aleatorios.

{pagebreak}

Tamén existen funcións propias segundo o tipo de dato co que traballemos, como é o caso de das cadeas de texto, onde podemos converter o seu valor a números o saber que a lonxitude total dos caracteres que o compoñen, etc...

Falaremos de todo isto nos próximos capítulos.



### Operadores especiais

En toda linguaxe de programación atoparemos certos operadores comúns que facilitárannos tarefas, como son:


Alxebraicos

: Relacionados con operacións matemáticas (sumar, restar, multiplicar, dividir...).


Relacionais

: Relacionados con comparacións entre elementos (distinto a, igual que, menor que, maior ou igual que...).


Lóxicos

: Permiten encadear validacións entre elementos. E (conxunción) e OU (disxunción).

: Por exemplo: ((é usuario) E (está rexistrado)) OU (é un invitado).
